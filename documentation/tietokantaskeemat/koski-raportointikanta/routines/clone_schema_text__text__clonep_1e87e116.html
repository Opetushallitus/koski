<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>raportointikanta.public</title>
        <!-- Tell the browser to be responsive to screen width -->
        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon.png">
        <!-- Bootstrap 3.3.5 -->
        <link rel="stylesheet" href="../bower/admin-lte/bootstrap/css/bootstrap.min.css">
        <!-- Font Awesome -->
        <link rel="stylesheet" href="../bower/font-awesome/css/font-awesome.min.css">
        <!-- Ionicons -->
        <link rel="stylesheet" href="../bower/ionicons/css/ionicons.min.css">
        <!-- DataTables -->
        <link rel="stylesheet" href="../bower/datatables.net-bs/css/dataTables.bootstrap.min.css">
        <link rel="stylesheet" href="../bower/datatables.net-buttons-bs/css/buttons.bootstrap.min.css">
        <!-- Code Mirror -->
        <link rel="stylesheet" href="../bower/codemirror/codemirror.css">
        <!-- Fonts -->
        <link href='../fonts/indieflower/indie-flower.css' rel='stylesheet' type='text/css'>
        <link href='../fonts/source-sans-pro/source-sans-pro.css' rel='stylesheet' type='text/css'>

        <!-- Theme style -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/AdminLTE.min.css">
        <!-- Salvattore -->
        <link rel="stylesheet" href="../bower/salvattore/salvattore.css">
        <!-- AdminLTE Skins. Choose a skin from the css/skins
           folder instead of downloading all of them to reduce the load. -->
        <link rel="stylesheet" href="../bower/admin-lte/dist/css/skins/_all-skins.min.css">
        <!-- SchemaSpy -->
        <link rel="stylesheet" href="../schemaSpy.css">

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
        <script src="../bower/html5shiv/html5shiv.min.js"></script>
        <script src="../bower/respond/respond.min.js"></script>
        <![endif]-->
    </head>
    <!-- ADD THE CLASS layout-top-nav TO REMOVE THE SIDEBAR. -->
    <body class="hold-transition skin-blue layout-top-nav">
        <div class="wrapper">
            <header class="main-header">
                <nav class="navbar navbar-static-top">
                    <div class="container">
                        <div class="navbar-header">
                            <a href="../index.html" class="navbar-brand"><b>raportointikanta</b></a><span class="navbar-brand" style="padding-left: 0">.public</span>
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse"><i class="fa fa-bars"></i></button>
                        </div>

                        <!-- Collect the nav links, forms, and other content for toggling -->
                        <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                            <ul class="nav navbar-nav">
                                <li><a href="../index.html">Tables <span class="sr-only">(current)</span></a></li>
                                <li><a href="../columns.html" title="All of the columns in the schema">Columns</a></li>
                                <li><a href="../constraints.html" title="Useful for diagnosing error messages that just give constraint name or number">Constraints</a></li>
                                <li><a href="../relationships.html" title="Diagram of table relationships">Relationships</a></li>
                                <li><a href="../orphans.html" title="View of tables with neither parents nor children">Orphan&nbsp;Tables</a></li>
                                <li><a href="../anomalies.html" title="Things that might not be quite right">Anomalies</a></li>
                                <li><a href="../routines.html" title="Procedures and functions">Routines</a></li>
                            </ul>
                        </div>
                        <!-- /.navbar-collapse -->
                        <!-- Navbar Right Menu -->
                    </div>
                    <!-- /.container-fluid -->
                </nav>
            </header>
            <!-- Main content -->
            <!-- Full Width Column -->
            <div class="content-wrapper">
                <!-- Content Header (Page header) -->
                <section class="content-header">
                    <h1>clone_schema(text, text, cloneparms[])</h1><br />
                </section>
                <!-- Main content -->
                <section class="content">
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <span class="glyphicon glyphicon-list-alt" aria-hidden="true"></span>
                            <h3 id="Columns" class="box-title">Parameters</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <table id="standard_table" class="table table-bordered table-striped dataTable" role="grid">
                                <thead align='left'>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Mode</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>source_schema</td>
                                    <td>text</td>
                                    <td>IN</td>
                                </tr>
                                <tr>
                                    <td>dest_schema</td>
                                    <td>text</td>
                                    <td>IN</td>
                                </tr>
                                <tr>
                                    <td>arr</td>
                                    <td>ARRAY</td>
                                    <td>IN</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="box box-primary">
                        <div class="box-header with-border">
                            <i class="fa fa-file-code-o"></i>
                            <h3 id="RoutineDefinition" class="box-title">Definition</h3>
                            <div class="box-tools pull-right">
                                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i></button>
                                <button type="button" class="btn btn-box-tool" data-widget="remove"><i class="fa fa-times"></i></button>
                            </div>
                        </div>
                        <div class="box-body">
                            <textarea id="sql-script-codemirror" name="sql-script-codemirror" rows="" style="display: none;">--  This function will clone all sequences, tables, data, views &amp; functions from any existing schema to a new one&#10;-- SAMPLE CALL:&#10;-- SELECT clone_schema(&#39;sample&#39;, &#39;sample_clone2&#39;);&#10;&#10;DECLARE&#10;  src_oid          oid;&#10;  tbl_oid          oid;&#10;  func_oid         oid;&#10;  object           text;&#10;  buffer           text;&#10;  buffer2          text;&#10;  buffer3          text;&#10;  srctbl           text;&#10;  aname            text;&#10;  default_         text;&#10;  column_          text;&#10;  qry              text;&#10;  ix_old_name      text;&#10;  ix_new_name      text;&#10;  relpersist       text;&#10;  udt_name         text;&#10;  udt_schema       text;&#10;  bRelispart       bool;&#10;  bChild           bool;&#10;  relknd           text;&#10;  data_type        text;&#10;  ocomment         text;&#10;  adef             text;&#10;  dest_qry         text;&#10;  v_def            text;&#10;  part_range       text;&#10;  src_path_old     text;&#10;  src_path_new     text;&#10;  aclstr           text;&#10;  -- issue#80 initialize arrays properly&#10;  tblarray         text[] :&#61; &#39;{}&#39;;&#10;  tblarray2        text[] :&#61; &#39;{}&#39;;&#10;  tblarray3        text[] :&#61; &#39;{}&#39;;&#10;  tblelement       text;&#10;  grantor          text;&#10;  grantee          text;&#10;  privs            text;&#10;  seqval           bigint;&#10;  sq_last_value    bigint;&#10;  sq_max_value     bigint;&#10;  sq_start_value   bigint;&#10;  sq_increment_by  bigint;&#10;  sq_min_value     bigint;&#10;  sq_cache_value   bigint;&#10;  sq_is_called     boolean :&#61; True;&#10;  sq_is_cycled     boolean;&#10;  is_prokind       boolean;&#10;  abool            boolean;&#10;  sq_data_type     text;&#10;  sq_cycled        char(10);&#10;  sq_owned         text;&#10;  sq_version        text;&#10;  sq_server_version text;&#10;  sq_server_version_num integer;&#10;  bWindows         boolean;&#10;  arec             RECORD;&#10;  cnt              integer;&#10;  cnt2             integer;&#10;  cnt3             integer;&#10;  pos              integer;&#10;  tblscopied       integer :&#61; 0;&#10;  l_child          integer;&#10;  action           text :&#61; &#39;N/A&#39;;&#10;  tblname          text;&#10;  v_ret            text;&#10;  v_diag1          text;&#10;  v_diag2          text;&#10;  v_diag3          text;&#10;  v_diag4          text;&#10;  v_diag5          text;&#10;  v_diag6          text;&#10;  v_dummy          text;&#10;  spath            text;&#10;  spath_tmp        text;&#10;  -- issue#86 fix&#10;  isGenerated      text;&#10;&#10;  -- issue#91 fix&#10;  tblowner         text;&#10;  func_owner       text;&#10;  func_name        text;&#10;  func_args        text;&#10;  func_argno       integer;&#10;  view_owner       text;&#10;&#10;  -- issue#92&#10;  calleruser       text;&#10;&#10;  -- issue#94&#10;  bData            boolean :&#61; False;&#10;  bDDLOnly         boolean :&#61; False;&#10;  bVerbose         boolean :&#61; False;&#10;  bDebug           boolean :&#61; False;&#10;  bNoACL           boolean :&#61; False;&#10;  bNoOwner         boolean :&#61; False;&#10;  arglen           integer;&#10;  vargs            text;&#10;  avarg            public.cloneparms;&#10;&#10;  -- issue#98&#10;  mvarray          text[] :&#61; &#39;{}&#39;;&#10;  mvscopied        integer :&#61; 0;&#10;&#10;  -- issue#99 tablespaces&#10;  tblspace         text;&#10;&#10;  -- issue#101&#10;  bFileCopy        boolean :&#61; False;&#10;&#10;  t                timestamptz :&#61; clock_timestamp();&#10;  r                timestamptz;&#10;  s                timestamptz;&#10;  v_version        text :&#61; &#39;1.18  August 04, 2023&#39;;&#10;&#10;BEGIN&#10;  -- Make sure NOTICE are shown&#10;  SET client_min_messages &#61; &#39;notice&#39;;&#10;  RAISE NOTICE &#39;clone_schema version %&#39;, v_version;&#10;&#10;  IF &#39;DEBUG&#39;   &#61; ANY ($3) THEN bDebug &#61; True; END IF;&#10;  IF &#39;VERBOSE&#39; &#61; ANY ($3) THEN bVerbose &#61; True; END IF;&#10;&#10;  -- IF bVerbose THEN RAISE NOTICE &#39;START: %&#39;,clock_timestamp() - t; END IF;&#10;&#10;  arglen :&#61; array_length($3, 1);&#10;  IF arglen IS NULL THEN&#10;    -- nothing to do, so defaults are assumed&#10;    NULL;&#10;  ELSE&#10;    -- loop thru args&#10;    -- IF &#39;NO_TRIGGERS&#39; &#61; ANY ($3)&#10;    -- select array_to_string($3, &#39;,&#39;, &#39;***&#39;) INTO vargs;&#10;    IF bDebug THEN RAISE NOTICE &#39;DEBUG: arguments&#61;%&#39;, $3; END IF;&#10;    FOREACH avarg IN ARRAY $3 LOOP&#10;      IF bDebug THEN RAISE NOTICE &#39;DEBUG: arg&#61;%&#39;, avarg; END IF;&#10;      IF avarg &#61; &#39;DATA&#39; THEN&#10;        bData &#61; True;&#10;      ELSEIF avarg &#61; &#39;NODATA&#39; THEN&#10;        -- already set to that by default&#10;        bData &#61; False;&#10;      ELSEIF avarg &#61; &#39;DDLONLY&#39; THEN&#10;        bDDLOnly &#61; True;&#10;      ELSEIF avarg &#61; &#39;NOACL&#39; THEN&#10;        bNoACL &#61; True;&#10;      ELSEIF avarg &#61; &#39;NOOWNER&#39; THEN&#10;        bNoOwner &#61; True;&#10;      -- issue#101 fix&#10;      ELSEIF avarg &#61; &#39;FILECOPY&#39; THEN&#10;        bFileCopy &#61; True;&#10;      END IF;&#10;    END LOOP;&#10;    IF bData and bDDLOnly THEN&#10;      RAISE WARNING &#39;You can only specify DDLONLY or DATA, but not both.&#39;;&#10;      RETURN;&#10;    END IF;&#10;  END IF;&#10;&#10;  -- Get server version info to handle certain things differently based on the version.&#10;  SELECT setting INTO sq_server_version&#10;  FROM pg_settings&#10;  WHERE name &#61; &#39;server_version&#39;;&#10;  SELECT version() INTO sq_version;&#10;&#10;  IF POSITION(&#39;compiled by Visual C++&#39; IN sq_version) &gt; 0 THEN&#10;      bWindows &#61; True;&#10;      RAISE NOTICE &#39;Windows: %&#39;, sq_version;&#10;  ELSE&#10;      bWindows &#61; False;&#10;      RAISE NOTICE &#39;Linux: %&#39;, sq_version;&#10;  END IF;&#10;  SELECT setting INTO sq_server_version_num&#10;  FROM pg_settings&#10;  WHERE name &#61; &#39;server_version_num&#39;;&#10;&#10;  IF sq_server_version_num &lt; 100000 THEN&#10;    RAISE WARNING &#39;Server Version:%  Number:%  PG Versions older than v10 are not supported.&#39;, sq_server_version, sq_server_version_num;&#10;    RETURN;&#10;  END IF;&#10;&#10;  -- Check that source_schema exists&#10;  SELECT oid INTO src_oid&#10;  FROM pg_namespace&#10;  WHERE nspname &#61; quote_ident(source_schema);&#10;&#10;  IF NOT FOUND&#10;    THEN&#10;    RAISE NOTICE &#39; source schema % does not exist!&#39;, source_schema;&#10;    RETURN ;&#10;  END IF;&#10;&#10;  -- Check for case-sensitive target schemas and reject them for now.&#10;  SELECT lower(dest_schema) &#61; dest_schema INTO abool;&#10;  IF not abool THEN&#10;      RAISE NOTICE &#39;Case-sensitive target schemas are not supported at this time.&#39;;&#10;      RETURN;&#10;  END IF;&#10;&#10;  -- Check that dest_schema does not yet exist&#10;  PERFORM nspname&#10;  FROM pg_namespace&#10;  WHERE nspname &#61; quote_ident(dest_schema);&#10;&#10;  IF FOUND&#10;    THEN&#10;    RAISE NOTICE &#39; dest schema % already exists!&#39;, dest_schema;&#10;    RETURN ;&#10;  END IF;&#10;  IF bDDLOnly and bData THEN&#10;    RAISE WARNING &#39;You cannot specify to clone data and generate ddl at the same time.&#39;;&#10;    RETURN ;&#10;  END IF;&#10;&#10;  -- Issue#92&#10;  SELECT current_user into calleruser;&#10;&#10;  -- Set the search_path to source schema. Before exiting set it back to what it was before.&#10;  -- In order to avoid issues with the special schema name &quot;$user&quot; that may be&#10;  -- returned unquoted by some applications, we ensure it remains double quoted.&#10;  -- MJV FIX: #47&#10;  SELECT setting INTO v_dummy FROM pg_settings WHERE name&#61;&#39;search_path&#39;;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: search_path&#61;%&#39;, v_dummy; END IF;&#10;&#10;  SELECT REPLACE(REPLACE(setting, &#39;&quot;$user&quot;&#39;, &#39;$user&#39;), &#39;$user&#39;, &#39;&quot;$user&quot;&#39;) INTO src_path_old&#10;  FROM pg_settings WHERE name &#61; &#39;search_path&#39;;&#10;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: src_path_old&#61;%&#39;, src_path_old; END IF;&#10;&#10;  EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;  SELECT setting INTO src_path_new FROM pg_settings WHERE name&#61;&#39;search_path&#39;;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: new search_path&#61;%&#39;, src_path_new; END IF;&#10;&#10;  -- Validate required types exist.  If not, create them.&#10;  SELECT a.objtypecnt, b.permtypecnt INTO cnt, cnt2&#10;  FROM (&#10;      SELECT count(*) AS objtypecnt&#10;      FROM pg_catalog.pg_type t&#10;      LEFT JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;  WHERE (t.typrelid &#61; 0&#10;      OR (&#10;          SELECT c.relkind &#61; &#39;c&#39;&#10;          FROM pg_catalog.pg_class c&#10;          WHERE c.oid &#61; t.typrelid))&#10;      AND NOT EXISTS (&#10;          SELECT 1&#10;          FROM pg_catalog.pg_type el&#10;          WHERE el.oid &#61; t.typelem&#10;              AND el.typarray &#61; t.oid)&#10;          AND n.nspname &lt;&gt; &#39;pg_catalog&#39;&#10;          AND n.nspname &lt;&gt; &#39;information_schema&#39;&#10;          AND pg_catalog.pg_type_is_visible(t.oid)&#10;          AND pg_catalog.format_type(t.oid, NULL) &#61; &#39;obj_type&#39;) a, (&#10;          SELECT count(*) AS permtypecnt&#10;          FROM pg_catalog.pg_type t&#10;          LEFT JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;      WHERE (t.typrelid &#61; 0&#10;          OR (&#10;              SELECT c.relkind &#61; &#39;c&#39;&#10;              FROM pg_catalog.pg_class c&#10;              WHERE c.oid &#61; t.typrelid))&#10;          AND NOT EXISTS (&#10;              SELECT 1&#10;              FROM pg_catalog.pg_type el&#10;              WHERE el.oid &#61; t.typelem&#10;                  AND el.typarray &#61; t.oid)&#10;              AND n.nspname &lt;&gt; &#39;pg_catalog&#39;&#10;              AND n.nspname &lt;&gt; &#39;information_schema&#39;&#10;              AND pg_catalog.pg_type_is_visible(t.oid)&#10;              AND pg_catalog.format_type(t.oid, NULL) &#61; &#39;perm_type&#39;) b;&#10;&#10;  IF cnt &#61; 0 THEN&#10;    CREATE TYPE obj_type AS ENUM (&#39;TABLE&#39;,&#39;VIEW&#39;,&#39;COLUMN&#39;,&#39;SEQUENCE&#39;,&#39;FUNCTION&#39;,&#39;SCHEMA&#39;,&#39;DATABASE&#39;);&#10;  END IF;&#10;  IF cnt2 &#61; 0 THEN&#10;    CREATE TYPE perm_type AS ENUM (&#39;SELECT&#39;,&#39;INSERT&#39;,&#39;UPDATE&#39;,&#39;DELETE&#39;,&#39;TRUNCATE&#39;,&#39;REFERENCES&#39;,&#39;TRIGGER&#39;,&#39;USAGE&#39;,&#39;CREATE&#39;,&#39;EXECUTE&#39;,&#39;CONNECT&#39;,&#39;TEMPORARY&#39;);&#10;  END IF;&#10;&#10;  -- Issue#95&#10;  SELECT pg_catalog.pg_get_userbyid(nspowner) INTO buffer FROM pg_namespace WHERE nspname &#61; quote_ident(source_schema);&#10;&#10;  IF bDDLOnly THEN&#10;    RAISE NOTICE &#39; Only generating DDL, not actually creating anything...&#39;;&#10;    -- issue#95&#10;    IF bNoOwner THEN&#10;        RAISE INFO &#39;CREATE SCHEMA %;&#39;, quote_ident(dest_schema);&#10;    ELSE&#10;        RAISE INFO &#39;CREATE SCHEMA % AUTHORIZATION %;&#39;, quote_ident(dest_schema), buffer;&#10;    END IF;&#10;    RAISE NOTICE &#39;SET search_path&#61;%;&#39;, quote_ident(dest_schema);&#10;  ELSE&#10;    -- issue#95&#10;    IF bNoOwner THEN&#10;        EXECUTE &#39;CREATE SCHEMA &#39; || quote_ident(dest_schema) ;&#10;    ELSE&#10;        EXECUTE &#39;CREATE SCHEMA &#39; || quote_ident(dest_schema) || &#39; AUTHORIZATION &#39; || buffer;&#10;    END IF;&#10;  END IF;&#10;&#10;  -- Do system table validations for subsequent system table queries&#10;  -- Issue#65 Fix&#10;  SELECT count(*) into cnt&#10;  FROM pg_attribute&#10;  WHERE  attrelid &#61; &#39;pg_proc&#39;::regclass AND attname &#61; &#39;prokind&#39;;&#10;&#10;  IF cnt &#61; 0 THEN&#10;      is_prokind &#61; False;&#10;  ELSE&#10;      is_prokind &#61; True;&#10;  END IF;&#10;&#10;  -- MV: Create Collations&#10;  action :&#61; &#39;Collations&#39;;&#10;  cnt :&#61; 0;&#10;  -- Issue#96 Handle differently based on PG Versions (PG15 rely on colliculocale, not collcolocate)&#10;  -- perhaps use this logic instead: COALESCE(c.collcollate, c.colliculocale) AS lc_collate, COALESCE(c.collctype, c.colliculocale) AS lc_type&#10;  IF sq_server_version_num &lt; 100000 THEN&#10;    RAISE NOTICE &#39; Collation cloning is are not supported in PG versions older than v10.  Current version is %-%&#39;, sq_server_version, sq_server_version_num;&#10;  ELSEIF sq_server_version_num &gt; 150000 THEN&#10;    FOR arec IN&#10;      SELECT n.nspname AS schemaname, a.rolname AS ownername, c.collname, c.collprovider, c.collcollate AS locale,&#10;             &#39;CREATE COLLATION &#39; || quote_ident(dest_schema) || &#39;.&quot;&#39; || c.collname || &#39;&quot; (provider &#61; &#39; ||&#10;             CASE WHEN c.collprovider &#61; &#39;i&#39; THEN &#39;icu&#39; WHEN c.collprovider &#61; &#39;c&#39; THEN &#39;libc&#39; ELSE &#39;&#39; END ||&#10;             &#39;, locale &#61; &#39;&#39;&#39; || c.colliculocale || &#39;&#39;&#39;);&#39; AS COLL_DDL&#10;      FROM pg_collation c&#10;          JOIN pg_namespace n ON (c.collnamespace &#61; n.oid)&#10;          JOIN pg_roles a ON (c.collowner &#61; a.oid)&#10;      WHERE n.nspname &#61; quote_ident(source_schema)&#10;      ORDER BY c.collname&#10;    LOOP&#10;      BEGIN&#10;        cnt :&#61; cnt + 1;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.coll_ddl;&#10;        ELSE&#10;          EXECUTE arec.coll_ddl;&#10;        END IF;&#10;      END;&#10;    END LOOP;&#10;  ELSE&#10;    FOR arec IN&#10;      SELECT n.nspname AS schemaname, a.rolname AS ownername, c.collname, c.collprovider, c.collcollate AS locale,&#10;             &#39;CREATE COLLATION &#39; || quote_ident(dest_schema) || &#39;.&quot;&#39; || c.collname || &#39;&quot; (provider &#61; &#39; ||&#10;             CASE WHEN c.collprovider &#61; &#39;i&#39; THEN &#39;icu&#39; WHEN c.collprovider &#61; &#39;c&#39; THEN &#39;libc&#39; ELSE &#39;&#39; END ||&#10;             &#39;, locale &#61; &#39;&#39;&#39; || c.collcollate || &#39;&#39;&#39;);&#39; AS COLL_DDL&#10;      FROM pg_collation c&#10;          JOIN pg_namespace n ON (c.collnamespace &#61; n.oid)&#10;          JOIN pg_roles a ON (c.collowner &#61; a.oid)&#10;      WHERE n.nspname &#61; quote_ident(source_schema)&#10;      ORDER BY c.collname&#10;    LOOP&#10;      BEGIN&#10;        cnt :&#61; cnt + 1;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.coll_ddl;&#10;        ELSE&#10;          EXECUTE arec.coll_ddl;&#10;        END IF;&#10;      END;&#10;    END LOOP;&#10;  END IF;&#10;  RAISE NOTICE &#39;  COLLATIONS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  -- MV: Create Domains&#10;  action :&#61; &#39;Domains&#39;;&#10;  cnt :&#61; 0;&#10;  FOR arec IN&#10;    SELECT n.nspname AS &quot;Schema&quot;, t.typname AS &quot;Name&quot;, pg_catalog.format_type(t.typbasetype, t.typtypmod) AS &quot;Type&quot;, (&#10;            SELECT c.collname&#10;            FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt&#10;            WHERE c.oid &#61; t.typcollation&#10;                AND bt.oid &#61; t.typbasetype&#10;                AND t.typcollation &lt;&gt; bt.typcollation) AS &quot;Collation&quot;, CASE WHEN t.typnotnull THEN&#10;            &#39;not null&#39;&#10;        END AS &quot;Nullable&quot;, t.typdefault AS &quot;Default&quot;, pg_catalog.array_to_string(ARRAY (&#10;                SELECT pg_catalog.pg_get_constraintdef(r.oid, TRUE)&#10;                FROM pg_catalog.pg_constraint r&#10;                -- Issue#78 FIX: handle case-sensitive names with quote_ident() on t.typename&#10;                WHERE t.oid &#61; r.contypid), &#39; &#39;) AS &quot;Check&quot;, &#39;CREATE DOMAIN &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(t.typname) || &#39; AS &#39; || pg_catalog.format_type(t.typbasetype, t.typtypmod) ||&#10;                CASE WHEN t.typnotnull IS NOT NULL THEN&#10;            &#39; NOT NULL &#39;&#10;        ELSE&#10;            &#39; &#39;&#10;        END || CASE WHEN t.typdefault IS NOT NULL THEN&#10;            &#39;DEFAULT &#39; || t.typdefault || &#39; &#39;&#10;        ELSE&#10;            &#39; &#39;&#10;        END || pg_catalog.array_to_string(ARRAY (&#10;                SELECT pg_catalog.pg_get_constraintdef(r.oid, TRUE)&#10;                FROM pg_catalog.pg_constraint r&#10;                WHERE t.oid &#61; r.contypid), &#39; &#39;) || &#39;;&#39; AS DOM_DDL&#10;    FROM pg_catalog.pg_type t&#10;        LEFT JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;    WHERE t.typtype &#61; &#39;d&#39;&#10;        AND n.nspname &#61; quote_ident(source_schema)&#10;        AND pg_catalog.pg_type_is_visible(t.oid)&#10;    ORDER BY 1, 2&#10;  LOOP&#10;    BEGIN&#10;      cnt :&#61; cnt + 1;&#10;      IF bDDLOnly THEN&#10;        RAISE INFO &#39;%&#39;, arec.dom_ddl;&#10;      ELSE&#10;        EXECUTE arec.dom_ddl;&#10;      END IF;&#10;    END;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;     DOMAINS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  -- MV: Create types&#10;  action :&#61; &#39;Types&#39;;&#10;  cnt :&#61; 0;&#10;  FOR arec IN&#10;    SELECT c.relkind, n.nspname AS schemaname, t.typname AS typname, t.typcategory, pg_catalog.pg_get_userbyid(t.typowner) AS owner, CASE WHEN t.typcategory &#61; &#39;C&#39; THEN&#10;            &#39;CREATE TYPE &#39; || quote_ident(dest_schema) || &#39;.&#39; || t.typname || &#39; AS (&#39; || array_to_string(array_agg(a.attname || &#39; &#39; || pg_catalog.format_type(a.atttypid, a.atttypmod)&#10;                ORDER BY c.relname, a.attnum), &#39;, &#39;) || &#39;);&#39;&#10;        WHEN t.typcategory &#61; &#39;E&#39; THEN&#10;            &#39;CREATE TYPE &#39; || quote_ident(dest_schema) || &#39;.&#39; || t.typname || &#39; AS ENUM (&#39; || REPLACE(quote_literal(array_to_string(array_agg(e.enumlabel ORDER BY e.enumsortorder), &#39;,&#39;)), &#39;,&#39;, &#39;&#39;&#39;,&#39;&#39;&#39;) || &#39;);&#39;&#10;        ELSE&#10;            &#39;&#39;&#10;        END AS type_ddl&#10;    FROM pg_type t&#10;        JOIN pg_namespace n ON (n.oid &#61; t.typnamespace)&#10;        LEFT JOIN pg_enum e ON (t.oid &#61; e.enumtypid)&#10;        LEFT JOIN pg_class c ON (c.reltype &#61; t.oid)&#10;        LEFT JOIN pg_attribute a ON (a.attrelid &#61; c.oid)&#10;    WHERE n.nspname &#61; quote_ident(source_schema)&#10;        AND (c.relkind IS NULL&#10;            OR c.relkind &#61; &#39;c&#39;)&#10;        AND t.typcategory IN (&#39;C&#39;, &#39;E&#39;)&#10;    GROUP BY 1, 2, 3, 4, 5&#10;    ORDER BY n.nspname, t.typcategory, t.typname&#10;&#10;  LOOP&#10;    BEGIN&#10;      cnt :&#61; cnt + 1;&#10;      -- Keep composite and enum types in separate branches for fine tuning later if needed.&#10;      IF arec.typcategory &#61; &#39;E&#39; THEN&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.type_ddl;&#10;&#10;          --issue#95&#10;          IF NOT bNoOwner THEN&#10;            RAISE INFO &#39;ALTER TYPE % OWNER TO  %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || arec.typname, arec.owner;&#10;          END IF;&#10;        ELSE&#10;          EXECUTE arec.type_ddl;&#10;&#10;          --issue#95&#10;          IF NOT bNoOwner THEN&#10;&#9;    EXECUTE &#39;ALTER TYPE &#39; || quote_ident(dest_schema) || &#39;.&#39; || arec.typname || &#39; OWNER TO &#39; || arec.owner;&#10;&#9;  END IF;&#10;&#10;        END IF;&#10;      ELSIF arec.typcategory &#61; &#39;C&#39; THEN&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.type_ddl;&#10;          --issue#95&#10;          IF NOT bNoOwner THEN&#10;            RAISE INFO &#39;ALTER TYPE % OWNER TO  %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || arec.typname, arec.owner;&#10;          END IF;&#10;&#10;        ELSE&#10;          EXECUTE arec.type_ddl;&#10;&#10;          --issue#95&#10;          IF NOT bNoOwner THEN&#10;&#9;    EXECUTE &#39;ALTER TYPE &#39; || quote_ident(dest_schema) || &#39;.&#39; || arec.typname || &#39; OWNER TO &#39; || arec.owner;&#10;&#9;  END IF;&#10;        END IF;&#10;      ELSE&#10;          RAISE NOTICE &#39; Unhandled type:%-%&#39;, arec.typcategory, arec.typname;&#10;      END IF;&#10;    END;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;       TYPES cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  -- Create sequences&#10;  action :&#61; &#39;Sequences&#39;;&#10;  cnt :&#61; 0;&#10;  -- fix#63  get from pg_sequences not information_schema&#10;  -- fix#63  take 2: get it from information_schema.sequences since we need to treat IDENTITY columns differently.&#10;  -- fix#95  get owner as well by joining to pg_sequences&#10;  FOR object, buffer IN&#10;    SELECT s1.sequence_name::text, s2.sequenceowner FROM information_schema.sequences s1&#10;    JOIN pg_sequences s2 ON (s1.sequence_schema &#61; s2.schemaname AND s1.sequence_name &#61; s2.sequencename)&#10;    AND s1.sequence_schema &#61; quote_ident(source_schema)&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    IF bDDLOnly THEN&#10;      -- issue#95&#10;      RAISE INFO &#39;%&#39;, &#39;CREATE SEQUENCE &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object) || &#39;;&#39;;&#10;      IF NOT bNoOwner THEN&#10;        RAISE INFO &#39;%&#39;, &#39;ALTER  SEQUENCE &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object) || &#39; OWNER TO &#39; || buffer || &#39;;&#39;;&#10;      END IF;&#10;    ELSE&#10;      EXECUTE &#39;CREATE SEQUENCE &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object);&#10;      -- issue#95&#10;      IF NOT bNoOwner THEN&#10;        EXECUTE &#39;ALTER SEQUENCE &#39;  || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object) || &#39; OWNER TO &#39; || buffer;&#10;      END IF;&#10;    END IF;&#10;    srctbl :&#61; quote_ident(source_schema) || &#39;.&#39; || quote_ident(object);&#10;&#10;    IF sq_server_version_num &lt; 100000 THEN&#10;      EXECUTE &#39;SELECT last_value, is_called FROM &#39; || quote_ident(source_schema) || &#39;.&#39; || quote_ident(object) || &#39;;&#39; INTO sq_last_value, sq_is_called;&#10;      EXECUTE &#39;SELECT maximum_value, start_value, increment, minimum_value, 1 cache_size, cycle_option, data_type&#10;               FROM information_schema.sequences WHERE sequence_schema&#61;&#39;|| quote_literal(source_schema) || &#39; AND sequence_name&#61;&#39; || quote_literal(object) || &#39;;&#39;&#10;               INTO sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_is_cycled, sq_data_type;&#10;      IF sq_is_cycled&#10;        THEN&#10;          sq_cycled :&#61; &#39;CYCLE&#39;;&#10;      ELSE&#10;          sq_cycled :&#61; &#39;NO CYCLE&#39;;&#10;      END IF;&#10;&#10;      qry :&#61; &#39;ALTER SEQUENCE &#39;   || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object)&#10;             || &#39; INCREMENT BY &#39; || sq_increment_by&#10;             || &#39; MINVALUE &#39;     || sq_min_value&#10;             || &#39; MAXVALUE &#39;     || sq_max_value&#10;             -- will update current sequence value after this&#10;             || &#39; START WITH &#39;   || sq_start_value&#10;             || &#39; RESTART &#39;      || sq_min_value&#10;             || &#39; CACHE &#39;        || sq_cache_value&#10;             || &#39; &#39;              || sq_cycled || &#39; ;&#39; ;&#10;    ELSE&#10;      EXECUTE &#39;SELECT max_value, start_value, increment_by, min_value, cache_size, cycle, data_type, COALESCE(last_value, 1)&#10;            FROM pg_catalog.pg_sequences WHERE schemaname&#61;&#39;|| quote_literal(source_schema) || &#39; AND sequencename&#61;&#39; || quote_literal(object) || &#39;;&#39;&#10;            INTO sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_is_cycled, sq_data_type, sq_last_value;&#10;      IF sq_is_cycled&#10;        THEN&#10;          sq_cycled :&#61; &#39;CYCLE&#39;;&#10;      ELSE&#10;          sq_cycled :&#61; &#39;NO CYCLE&#39;;&#10;      END IF;&#10;&#10;      qry :&#61; &#39;ALTER SEQUENCE &#39;   || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object)&#10;             || &#39; AS &#39; || sq_data_type&#10;             || &#39; INCREMENT BY &#39; || sq_increment_by&#10;             || &#39; MINVALUE &#39;     || sq_min_value&#10;             || &#39; MAXVALUE &#39;     || sq_max_value&#10;             -- will update current sequence value after this&#10;             || &#39; START WITH &#39;   || sq_start_value&#10;             || &#39; RESTART &#39;      || sq_min_value&#10;             || &#39; CACHE &#39;        || sq_cache_value&#10;             || &#39; &#39;              || sq_cycled || &#39; ;&#39; ;&#10;    END IF;&#10;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, qry;&#10;    ELSE&#10;      EXECUTE qry;&#10;    END IF;&#10;&#10;    buffer :&#61; quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object);&#10;    IF bData THEN&#10;      EXECUTE &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_last_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;    ELSE&#10;      if bDDLOnly THEN&#10;        -- fix#63&#10;        --  RAISE INFO &#39;%&#39;, &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_start_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;        RAISE INFO &#39;%&#39;, &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_last_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;      ELSE&#10;        -- fix#63&#10;        -- EXECUTE &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_start_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;        EXECUTE &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_last_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;      END IF;&#10;&#10;    END IF;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;   SEQUENCES cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;&#10;  -- Create tables including partitioned ones (parent/children) and unlogged ones.  Order by is critical since child partition range logic is dependent on it.&#10;  action :&#61; &#39;Tables&#39;;&#10;  SELECT setting INTO v_dummy FROM pg_settings WHERE name&#61;&#39;search_path&#39;;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: search_path&#61;%&#39;, v_dummy; END IF;&#10;&#10;  cnt :&#61; 0;&#10;  -- Issue#61 FIX: use set_config for empty string&#10;  -- SET search_path &#61; &#39;&#39;;&#10;  SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false) into v_dummy;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: setting search_path to empty string:%&#39;, v_dummy; END IF;&#10;  -- Fix#86 add isgenerated to column list&#10;  -- Fix#91 add tblowner for setting the table ownership to that of the source&#10;  -- Fix#99 added join to pg_tablespace&#10;  FOR tblname, relpersist, bRelispart, relknd, data_type, udt_name, udt_schema, ocomment, l_child, isGenerated, tblowner, tblspace  IN&#10;    -- 2021-03-08 MJV #39 fix: change sql to get indicator of user-defined columns to issue warnings&#10;    -- select c.relname, c.relpersistence, c.relispartition, c.relkind&#10;    -- FROM pg_class c, pg_namespace n where n.oid &#61; c.relnamespace and n.nspname &#61; quote_ident(source_schema) and c.relkind in (&#39;r&#39;,&#39;p&#39;) and&#10;    -- order by c.relkind desc, c.relname&#10;    --Fix#65 add another left join to distinguish child tables by inheritance&#10;    -- Fix#86 add is_generated to column select&#10;    -- Fix#91 add tblowner to the select&#10;    -- Fix#105 need a different kinda distint to avoid retrieving a table twice in the case of a table with multiple USER-DEFINED datatypes using DISTINCT ON instead of just DISTINCT&#10;    --SELECT DISTINCT c.relname, c.relpersistence, c.relispartition, c.relkind, co.data_type, co.udt_name, co.udt_schema, obj_description(c.oid), i.inhrelid,&#10;    --                COALESCE(co.is_generated, &#39;&#39;), pg_catalog.pg_get_userbyid(c.relowner) as &quot;Owner&quot;, CASE WHEN reltablespace &#61; 0 THEN &#39;pg_default&#39; ELSE ts.spcname END as tablespace&#10;    SELECT DISTINCT ON (c.relname, c.relpersistence, c.relispartition, c.relkind, co.data_type) c.relname, c.relpersistence, c.relispartition, c.relkind, co.data_type, co.udt_name, co.udt_schema, obj_description(c.oid), i.inhrelid,&#10;                    COALESCE(co.is_generated, &#39;&#39;), pg_catalog.pg_get_userbyid(c.relowner) as &quot;Owner&quot;, CASE WHEN reltablespace &#61; 0 THEN &#39;pg_default&#39; ELSE ts.spcname END as tablespace&#10;    FROM pg_class c&#10;        JOIN pg_namespace n ON (n.oid &#61; c.relnamespace&#10;                AND n.nspname &#61; quote_ident(source_schema)&#10;                AND c.relkind IN (&#39;r&#39;, &#39;p&#39;))&#10;        LEFT JOIN information_schema.columns co ON (co.table_schema &#61; n.nspname&#10;                AND co.table_name &#61; c.relname&#10;                AND (co.data_type &#61; &#39;USER-DEFINED&#39; OR co.is_generated &#61; &#39;ALWAYS&#39;))&#10;        LEFT JOIN pg_inherits i ON (c.oid &#61; i.inhrelid)&#10;        -- issue#99 added join&#10;        LEFT JOIN pg_tablespace ts ON (c.reltablespace &#61; ts.oid)&#10;    ORDER BY c.relkind DESC, c.relname&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    IF l_child IS NULL THEN&#10;      bChild :&#61; False;&#10;    ELSE&#10;      bChild :&#61; True;&#10;    END IF;&#10;    IF bDebug THEN RAISE NOTICE &#39;DEBUG: TABLE START --&gt; table&#61;%  bRelispart&#61;%  relkind&#61;%  bChild&#61;%&#39;,tblname, bRelispart, relknd, bChild; END IF;&#10;&#10;    IF data_type &#61; &#39;USER-DEFINED&#39; THEN&#10;      -- RAISE NOTICE &#39; Table (%) has column(s) with user-defined types so using get_table_ddl() instead of CREATE TABLE LIKE construct.&#39;,tblname;&#10;      cnt :&#61;cnt;&#10;    END IF;&#10;    buffer :&#61; quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname);&#10;    buffer2 :&#61; &#39;&#39;;&#10;    IF relpersist &#61; &#39;u&#39; THEN&#10;      buffer2 :&#61; &#39;UNLOGGED &#39;;&#10;    END IF;&#10;    IF relknd &#61; &#39;r&#39; THEN&#10;      IF bDDLOnly THEN&#10;        IF data_type &#61; &#39;USER-DEFINED&#39; THEN&#10;          -- FIXED #65, #67&#10;          -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);&#10;          SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);&#10;&#10;          buffer3 :&#61; REPLACE(buffer3, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;);&#10;          RAISE INFO &#39;%&#39;, buffer3;&#10;          -- issue#91 fix&#10;          -- issue#95&#10;          IF NOT bNoOwner THEN&#10;            RAISE INFO &#39;ALTER TABLE IF EXISTS % OWNER TO %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || tblname, tblowner;&#10;          END IF;&#10;        ELSE&#10;          IF NOT bChild THEN&#10;            RAISE INFO &#39;%&#39;, &#39;CREATE &#39; || buffer2 || &#39;TABLE &#39; || buffer || &#39; (LIKE &#39; || quote_ident(source_schema) || &#39;.&#39; || quote_ident(tblname) || &#39; INCLUDING ALL);&#39;;&#10;            -- issue#91 fix&#10;             -- issue#95&#10;            IF NOT bNoOwner THEN&#10;              RAISE INFO &#39;ALTER TABLE IF EXISTS % OWNER TO %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || tblname, tblowner;&#10;            END IF;&#10;&#10;            -- issue#99&#10;            IF tblspace &lt;&gt; &#39;pg_default&#39; THEN&#10;              -- replace with user-defined tablespace&#10;              -- ALTER TABLE myschema.mytable SET TABLESPACE usrtblspc;&#10;              RAISE INFO &#39;ALTER TABLE IF EXISTS % SET TABLESPACE %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || tblname, tblspace;&#10;            END IF;&#10;          ELSE&#10;            -- FIXED #65, #67&#10;            -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);&#10;            SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);&#10;            buffer3 :&#61; REPLACE(buffer3, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;);&#10;            RAISE INFO &#39;%&#39;, buffer3;&#10;            -- issue#91 fix&#10;            -- issue#95&#10;            IF NOT bNoOwner THEN&#10;              RAISE INFO &#39;ALTER TABLE IF EXISTS % OWNER TO %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || tblname, tblowner;&#10;            END IF;&#10;          END IF;&#10;        END IF;&#10;      ELSE&#10;        IF data_type &#61; &#39;USER-DEFINED&#39; THEN&#10;          -- FIXED #65, #67&#10;          -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);&#10;          SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);&#10;          buffer3 :&#61; REPLACE(buffer3, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;);&#10;          IF bDebug THEN RAISE NOTICE &#39;DEBUG: tabledef01:%&#39;, buffer3; END IF;&#10;          -- #82: Table def should be fully qualified with target schema,&#10;          --      so just make search path &#61; public to handle extension types that should reside in public schema&#10;          v_dummy &#61; &#39;public&#39;;&#10;          SELECT set_config(&#39;search_path&#39;, v_dummy, false) into v_dummy;&#10;          EXECUTE buffer3;&#10;          -- issue#91 fix&#10;          -- issue#95&#10;          IF NOT bNoOwner THEN&#10;            buffer3 &#61; &#39;ALTER TABLE IF EXISTS &#39; || quote_ident(dest_schema) || &#39;.&#39; || tblname || &#39; OWNER TO &#39; || tblowner;&#10;            EXECUTE buffer3;&#10;          END IF;&#10;        ELSE&#10;          IF (NOT bChild OR bRelispart) THEN&#10;            buffer3 :&#61; &#39;CREATE &#39; || buffer2 || &#39;TABLE &#39; || buffer || &#39; (LIKE &#39; || quote_ident(source_schema) || &#39;.&#39; || quote_ident(tblname) || &#39; INCLUDING ALL)&#39;;&#10;            IF bDebug THEN RAISE NOTICE &#39;DEBUG: tabledef02:%&#39;, buffer3; END IF;&#10;            EXECUTE buffer3;&#10;            -- issue#91 fix&#10;            -- issue#95&#10;            IF NOT bNoOwner THEN&#10;              buffer3 &#61; &#39;ALTER TABLE IF EXISTS &#39; || quote_ident(dest_schema) || &#39;.&#39;  || quote_ident(tblname) || &#39; OWNER TO &#39; || tblowner;&#10;              EXECUTE buffer3;&#10;            END IF;&#10;&#10;            -- issue#99&#10;            IF tblspace &lt;&gt; &#39;pg_default&#39; THEN&#10;              -- replace with user-defined tablespace&#10;              -- ALTER TABLE myschema.mytable SET TABLESPACE usrtblspc;&#10;              buffer3 &#61; &#39;ALTER TABLE IF EXISTS &#39; || quote_ident(dest_schema) || &#39;.&#39; || tblname || &#39; SET TABLESPACE &#39; || tblspace;&#10;              EXECUTE buffer3;&#10;            END IF;&#10;&#10;          ELSE&#10;            -- FIXED #65, #67&#10;            -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);&#10;            SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);&#10;&#10;            buffer3 :&#61; REPLACE(buffer3, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;);&#10;            -- set client_min_messages higher to avoid messages like this:&#10;            -- NOTICE:  merging column &quot;city_id&quot; with inherited definition&#10;            set client_min_messages &#61; &#39;WARNING&#39;;&#10;            IF bDebug THEN RAISE NOTICE &#39;DEBUG: tabledef03:%&#39;, buffer3; END IF;&#10;            EXECUTE buffer3;&#10;            -- issue#91 fix&#10;            -- issue#95&#10;            IF NOT bNoOwner THEN&#10;              buffer3 &#61; &#39;ALTER TABLE IF EXISTS &#39; || quote_ident(dest_schema) || &#39;.&#39; || tblname || &#39; OWNER TO &#39; || tblowner;&#10;              EXECUTE buffer3;&#10;            END IF;&#10;&#10;            -- reset it back, only get these for inheritance-based tables&#10;            set client_min_messages &#61; &#39;notice&#39;;&#10;          END IF;&#10;        END IF;&#10;        -- Add table comment.&#10;        IF ocomment IS NOT NULL THEN&#10;          EXECUTE &#39;COMMENT ON TABLE &#39; || buffer || &#39; IS &#39; || quote_literal(ocomment);&#10;        END IF;&#10;      END IF;&#10;    ELSIF relknd &#61; &#39;p&#39; THEN&#10;      -- define parent table and assume child tables have already been created based on top level sort order.&#10;      -- Issue #103 Put the complex query into its own function, get_table_ddl_complex()&#10;      SELECT * INTO qry FROM public.get_table_ddl_complex(source_schema, dest_schema, tblname, sq_server_version_num);&#10;      IF bDebug THEN RAISE NOTICE &#39;DEBUG: tabledef04 - %&#39;, buffer; END IF;&#10;&#10;      -- consider replacing complicated query above with this simple call to get_table_ddl()...&#10;      -- SELECT * INTO qry FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);&#10;      -- qry :&#61; REPLACE(qry, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;);&#10;&#10;      IF bDDLOnly THEN&#10;        RAISE INFO &#39;%&#39;, qry;&#10;        -- issue#95&#10;        IF NOT bNoOwner THEN&#10;            RAISE INFO &#39;ALTER TABLE IF EXISTS % OWNER TO %;&#39;, quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname), tblowner;&#10;        END IF;&#10;      ELSE&#10;        -- Issue#103: we need to always set search_path priority to target schema when we execute DDL&#10;        IF bDebug THEN RAISE NOTICE &#39;DEBUG: tabledef04 context: old search path&#61;%  new search path&#61;% current search path&#61;%&#39;, src_path_old, src_path_new, v_dummy; END IF;&#10;        SELECT setting INTO spath_tmp FROM pg_settings WHERE name &#61; &#39;search_path&#39;;&#10;        IF spath_tmp &lt;&gt; dest_schema THEN&#10;          -- change it to target schema and don&#39;t forget to change it back after we execute the DDL&#10;          spath &#61; &#39;SET search_path &#61; &quot;&#39; || dest_schema || &#39;&quot;&#39;;&#10;          IF bDebug THEN RAISE NOTICE &#39;DEBUG: changing search_path --&gt; %&#39;, spath; END IF;&#10;          EXECUTE spath;&#10;          SELECT setting INTO v_dummy FROM pg_settings WHERE name &#61; &#39;search_path&#39;;&#10;          IF bDebug THEN RAISE NOTICE &#39;DEBUG: search_path changed to %&#39;, v_dummy; END IF;&#10;        END IF;&#10;        IF bDebug THEN RAISE NOTICE &#39;DEBUG: tabledef04:%&#39;, qry; END IF;&#10;        EXECUTE qry;&#10;&#10;        -- Issue#103&#10;        -- Set search path back to what it was&#10;        spath &#61; &#39;SET search_path &#61; &quot;&#39; || spath_tmp || &#39;&quot;&#39;;&#10;        EXECUTE spath;&#10;        SELECT setting INTO v_dummy FROM pg_settings WHERE name &#61; &#39;search_path&#39;;&#10;        IF bDebug THEN RAISE NOTICE &#39;DEBUG: search_path changed back to %&#39;, v_dummy; END IF;&#10;&#10;        -- issue#91 fix&#10;        -- issue#95&#10;        IF NOT bNoOwner THEN&#10;          buffer3 &#61; &#39;ALTER TABLE IF EXISTS &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname) || &#39; OWNER TO &#39; || tblowner;&#10;          EXECUTE buffer3;&#10;        END IF;&#10;&#10;      END IF;&#10;      -- loop for child tables and alter them to attach to parent for specific partition method.&#10;      -- Issue#103 fix: only loop for the table we are currently processing, tblname!&#10;      FOR aname, part_range, object IN&#10;        SELECT quote_ident(dest_schema) || &#39;.&#39; || c1.relname as tablename, pg_catalog.pg_get_expr(c1.relpartbound, c1.oid) as partrange, quote_ident(dest_schema) || &#39;.&#39; || c2.relname as object&#10;        FROM pg_catalog.pg_class c1, pg_namespace n, pg_catalog.pg_inherits i, pg_class c2&#10;        WHERE n.nspname &#61; quote_ident(source_schema) AND c1.relnamespace &#61; n.oid AND c1.relkind &#61; &#39;r&#39;&#10;        -- Issue#103: added this condition to only work on current partitioned table.  The problem was regression testing previously only worked on one partition table clone case&#10;        AND c2.relname &#61; tblname AND&#10;        c1.relispartition AND c1.oid&#61;i.inhrelid AND i.inhparent &#61; c2.oid AND c2.relnamespace &#61; n.oid ORDER BY pg_catalog.pg_get_expr(c1.relpartbound, c1.oid) &#61; &#39;DEFAULT&#39;,&#10;        c1.oid::pg_catalog.regclass::pg_catalog.text&#10;      LOOP&#10;        qry :&#61; &#39;ALTER TABLE ONLY &#39; || object || &#39; ATTACH PARTITION &#39; || aname || &#39; &#39; || part_range || &#39;;&#39;;&#10;        IF bDebug THEN RAISE NOTICE &#39;DEBUG: %&#39;,qry; END IF;&#10;        -- issue#91, not sure if we need to do this for child tables&#10;        -- issue#95 we dont set ownership here&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, qry;&#10;          IF NOT bNoOwner THEN&#10;            NULL;&#10;          END IF;&#10;        ELSE&#10;          EXECUTE qry;&#10;          IF NOT bNoOwner THEN&#10;            NULL;&#10;          END IF;&#10;        END IF;&#10;      END LOOP;&#10;    END IF;&#10;    -- INCLUDING ALL creates new index names, we restore them to the old name.&#10;    -- There should be no conflicts since they live in different schemas&#10;    FOR ix_old_name, ix_new_name IN&#10;      SELECT old.indexname, new.indexname&#10;      FROM pg_indexes old, pg_indexes new&#10;      WHERE old.schemaname &#61; source_schema&#10;        AND new.schemaname &#61; dest_schema&#10;        AND old.tablename &#61; new.tablename&#10;        AND old.tablename &#61; tblname&#10;        AND old.indexname &lt;&gt; new.indexname&#10;        AND regexp_replace(old.indexdef, E&#39;.*USING&#39;,&#39;&#39;) &#61; regexp_replace(new.indexdef, E&#39;.*USING&#39;,&#39;&#39;)&#10;        ORDER BY old.indexdef, new.indexdef&#10;    LOOP&#10;      IF bDDLOnly THEN&#10;        RAISE INFO &#39;%&#39;, &#39;ALTER INDEX &#39; || quote_ident(dest_schema) || &#39;.&#39;  || quote_ident(ix_new_name) || &#39; RENAME TO &#39; || quote_ident(ix_old_name) || &#39;;&#39;;&#10;      ELSE&#10;        -- The SELECT query above may return duplicate names when a column is&#10;        -- indexed twice the same manner with 2 different names. Therefore, to&#10;        -- avoid a &#39;relation &quot;xxx&quot; already exists&#39; we test if the index name&#10;        -- is in use or free. Skipping existing index will fallback on unused&#10;        -- ones and every duplicate will be mapped to distinct old names.&#10;        IF NOT EXISTS (&#10;            SELECT TRUE&#10;            FROM pg_indexes&#10;            WHERE schemaname &#61; dest_schema&#10;              AND tablename &#61; tblname&#10;              AND indexname &#61; quote_ident(ix_old_name))&#10;          AND EXISTS (&#10;            SELECT TRUE&#10;            FROM pg_indexes&#10;            WHERE schemaname &#61; dest_schema&#10;              AND tablename &#61; tblname&#10;              AND indexname &#61; quote_ident(ix_new_name))&#10;          THEN&#10;          EXECUTE &#39;ALTER INDEX &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(ix_new_name) || &#39; RENAME TO &#39; || quote_ident(ix_old_name) || &#39;;&#39;;&#10;        END IF;&#10;      END IF;&#10;    END LOOP;&#10;&#10;    IF bData THEN&#10;      -- Insert records from source table&#10;&#10;      -- 2021-03-03  MJV FIX&#10;      buffer :&#61; dest_schema || &#39;.&#39; || quote_ident(tblname);&#10;&#10;      -- 2020/06/18 - Issue #31 fix: add &quot;OVERRIDING SYSTEM VALUE&quot; for IDENTITY columns marked as GENERATED ALWAYS.&#10;      select count(*) into cnt2 from pg_class c, pg_attribute a, pg_namespace n&#10;          where a.attrelid &#61; c.oid and c.relname &#61; quote_ident(tblname) and n.oid &#61; c.relnamespace and n.nspname &#61; quote_ident(source_schema) and a.attidentity &#61; &#39;a&#39;;&#10;      buffer3 :&#61; &#39;&#39;;&#10;      IF cnt2 &gt; 0 THEN&#10;          buffer3 :&#61; &#39; OVERRIDING SYSTEM VALUE&#39;;&#10;      END IF;&#10;      -- BUG for inserting rows from tables with user-defined columns&#10;      -- INSERT INTO sample_clone.address OVERRIDING SYSTEM VALUE SELECT * FROM sample.address;&#10;      -- ERROR:  column &quot;id2&quot; is of type sample_clone.udt_myint but expression is of type udt_myint&#10;&#10;      -- Issue#86 fix:&#10;      -- IF data_type &#61; &#39;USER-DEFINED&#39; THEN&#10;      IF bDebug THEN RAISE NOTICE &#39;DEBUG: includerecs branch  table&#61;%  data_type&#61;%  isgenerated&#61;%&#39;, tblname, data_type, isGenerated; END IF;&#10;      IF data_type &#61; &#39;USER-DEFINED&#39; OR isGenerated &#61; &#39;ALWAYS&#39; THEN&#10;&#10;        -- RAISE WARNING &#39;Bypassing copying rows for table (%) with user-defined data types.  You must copy them manually.&#39;, tblname;&#10;        -- wont work --&gt; INSERT INTO clone1.address (id2, id3, addr) SELECT cast(id2 as clone1.udt_myint), cast(id3 as clone1.udt_myint), addr FROM sample.address;&#10;        -- Issue#101 --&gt; INSERT INTO clone1.address2 (id2, id3, addr) SELECT id2::text::clone1.udt_myint, id3::text::clone1.udt_myint, addr FROM sample.address;&#10;&#10;        -- Issue#79 implementation follows&#10;        -- COPY sample.statuses(id, s) TO &#39;/tmp/statuses.txt&#39; WITH DELIMITER AS &#39;,&#39;;&#10;        -- COPY sample_clone1.statuses FROM &#39;/tmp/statuses.txt&#39; (DELIMITER &#39;,&#39;, NULL &#39;&#39;);&#10;        -- Issue#101 fix: use text cast to get around the problem.&#10;        IF bFileCopy THEN&#10;          IF bWindows THEN&#10;              buffer2   :&#61; &#39;COPY &#39; || quote_ident(source_schema) || &#39;.&#39; || quote_ident(tblname) || &#39; TO  &#39;&#39;C:\WINDOWS\TEMP\cloneschema.tmp&#39;&#39; WITH DELIMITER AS &#39;&#39;,&#39;&#39;;&#39;;&#10;              tblarray2 :&#61; tblarray2 || buffer2;&#10;              -- Issue #81 reformat COPY command for upload&#10;              -- buffer2:&#61; &#39;COPY &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname) || &#39;  FROM  &#39;&#39;C:\WINDOWS\TEMP\cloneschema.tmp&#39;&#39; (DELIMITER &#39;&#39;,&#39;&#39;, NULL &#39;&#39;&#39;&#39;);&#39;;&#10;              buffer2   :&#61; &#39;COPY &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname) || &#39;  FROM  &#39;&#39;C:\WINDOWS\TEMP\cloneschema.tmp&#39;&#39; (DELIMITER &#39;&#39;,&#39;&#39;, NULL &#39;&#39;\N&#39;&#39;, FORMAT CSV);&#39;;&#10;              tblarray2 :&#61; tblarray2 || buffer2;&#10;          ELSE&#10;              buffer2   :&#61; &#39;COPY &#39; || quote_ident(source_schema) || &#39;.&#39; || quote_ident(tblname) || &#39; TO &#39;&#39;/tmp/cloneschema.tmp&#39;&#39; WITH DELIMITER AS &#39;&#39;,&#39;&#39;;&#39;;&#10;              tblarray2 :&#61; tblarray2 || buffer2;&#10;              -- Issue #81 reformat COPY command for upload&#10;              -- buffer2   :&#61; &#39;COPY &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname) || &#39;  FROM &#39;&#39;/tmp/cloneschema.tmp&#39;&#39; (DELIMITER &#39;&#39;,&#39;&#39;, NULL &#39;&#39;&#39;&#39;);&#39;;&#10;              -- works--&gt; COPY sample.timestamptbl2  FROM &#39;/tmp/cloneschema.tmp&#39; WITH (DELIMITER &#39;,&#39;, NULL &#39;\N&#39;, FORMAT CSV) ;&#10;              buffer2   :&#61; &#39;COPY &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tblname) || &#39;  FROM &#39;&#39;/tmp/cloneschema.tmp&#39;&#39; (DELIMITER &#39;&#39;,&#39;&#39;, NULL &#39;&#39;\N&#39;&#39;, FORMAT CSV);&#39;;&#10;              tblarray2 :&#61; tblarray2 || buffer2;&#10;          END IF;&#10;        ELSE&#10;          -- Issue#101: assume direct copy with text cast, add to separate array&#10;          SELECT * INTO buffer3 FROM public.get_insert_stmt_ddl(quote_ident(source_schema), quote_ident(dest_schema), quote_ident(tblname), True);&#10;          tblarray3 :&#61; tblarray3 || buffer3;&#10;        END IF;&#10;      ELSE&#10;        -- bypass child tables since we populate them when we populate the parents&#10;        -- RAISE NOTICE &#39;tblname&#61;%  bRelispart&#61;%  relknd&#61;%  l_child&#61;%  bChild&#61;%&#39;, tblname, bRelispart, relknd, l_child, bChild;&#10;        IF NOT bRelispart AND NOT bChild THEN&#10;          -- Issue#75: Must defer population of tables until child tables have been added to parents&#10;          -- Issue#101 Offer alternative of copy to/from file. Although originally intended for tables with UDTs, it is now expanded to handle all cases for performance improvement perhaps for large tables.&#10;          buffer2 :&#61; &#39;INSERT INTO &#39; || buffer || buffer3 || &#39; SELECT * FROM &#39; || quote_ident(source_schema) || &#39;.&#39; || quote_ident(tblname) || &#39;;&#39;;&#10;          IF bFileCopy THEN&#10;            tblarray2:&#61; tblarray2 || buffer2;&#10;          ELSE&#10;            tblarray :&#61; tblarray || buffer2;&#10;          END IF;&#10;        END IF;&#10;      END IF;&#10;    END IF;&#10;&#10;    -- Issue#61 FIX: use set_config for empty string&#10;    -- SET search_path &#61; &#39;&#39;;&#10;    SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false) into v_dummy;&#10;&#10;    FOR column_, default_ IN&#10;      SELECT column_name::text,&#10;             REPLACE(column_default::text, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;)&#10;      FROM information_schema.COLUMNS&#10;      WHERE table_schema &#61; source_schema&#10;          AND TABLE_NAME &#61; tblname&#10;          AND column_default LIKE &#39;nextval(%&#39; || quote_ident(source_schema) || &#39;%::regclass)&#39;&#10;    LOOP&#10;      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on column name&#10;      buffer2 &#61; &#39;ALTER TABLE &#39; || buffer || &#39; ALTER COLUMN &#39; || quote_ident(column_) || &#39; SET DEFAULT &#39; || default_ || &#39;;&#39;;&#10;      IF bDDLOnly THEN&#10;        -- May need to come back and revisit this since previous sql will not return anything since no schema as created!&#10;        RAISE INFO &#39;%&#39;, buffer2;&#10;      ELSE&#10;        EXECUTE buffer2;&#10;      END IF;&#10;    END LOOP;&#10;&#10;    EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;      TABLES cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  SELECT setting INTO v_dummy FROM pg_settings WHERE name &#61; &#39;search_path&#39;;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: search_path&#61;%&#39;, v_dummy; END IF;&#10;&#10;  -- Assigning sequences to table columns.&#10;  action :&#61; &#39;Sequences assigning&#39;;&#10;  cnt :&#61; 0;&#10;  FOR object IN&#10;    SELECT sequence_name::text&#10;    FROM information_schema.sequences&#10;    WHERE sequence_schema &#61; quote_ident(source_schema)&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    srctbl :&#61; quote_ident(source_schema) || &#39;.&#39; || quote_ident(object);&#10;&#10;    -- Get owning column, inspired from Sadique Ali post at:&#10;    -- https://sadique.io/blog/2019/05/07/viewing-sequence-ownership-information-in-postgres/&#10;    SELECT &#39; OWNED BY &#39;&#10;      || quote_ident(dest_schema)&#10;      || &#39;.&#39;&#10;      || quote_ident(dc.relname)&#10;      || &#39;.&#39;&#10;      || quote_ident(a.attname)&#10;    INTO sq_owned&#10;    FROM pg_class AS c&#10;      JOIN pg_depend AS d ON (c.relfilenode &#61; d.objid)&#10;      JOIN pg_class AS dc ON (d.refobjid &#61; dc.relfilenode)&#10;      JOIN pg_attribute AS a ON (&#10;        a.attnum &#61; d.refobjsubid&#10;        AND a.attrelid &#61; d.refobjid&#10;      )&#10;      JOIN pg_namespace n ON c.relnamespace &#61; n.oid&#10;    WHERE n.nspname &#61; quote_ident(source_schema)&#10;      AND c.relkind &#61; &#39;S&#39;&#10;      AND c.relname &#61; object;&#10;&#10;    IF sq_owned IS NOT NULL THEN&#10;      qry :&#61; &#39;ALTER SEQUENCE &#39;&#10;        || quote_ident(dest_schema)&#10;        || &#39;.&#39;&#10;        || quote_ident(object)&#10;        || sq_owned&#10;        || &#39;;&#39;;&#10;&#10;      IF bDDLOnly THEN&#10;        RAISE INFO &#39;%&#39;, qry;&#10;      ELSE&#10;        EXECUTE qry;&#10;      END IF;&#10;&#10;    END IF;&#10;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;    SEQUENCES set:      %&#39;, LPAD(cnt::text, 2, &#39; &#39;);&#10;&#10;  -- Update IDENTITY sequences to the last value&#10;  action :&#61; &#39;Identity updating&#39;;&#10;  cnt :&#61; 0;&#10;  FOR object, sq_last_value IN&#10;    SELECT sequencename::text, COALESCE(last_value, -999) from pg_sequences where schemaname &#61; quote_ident(source_schema)&#10;    AND NOT EXISTS&#10;    (select 1 from information_schema.sequences where sequence_schema &#61; quote_ident(source_schema) and sequence_name &#61; sequencename)&#10;  LOOP&#10;    IF sq_last_value &#61; -999 THEN&#10;      continue;&#10;    END IF;&#10;    cnt :&#61; cnt + 1;&#10;    buffer :&#61; quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object);&#10;    IF bData THEN&#10;      EXECUTE &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_last_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;    ELSE&#10;      if bDDLOnly THEN&#10;        -- fix#63&#10;        RAISE INFO &#39;%&#39;, &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_last_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;      ELSE&#10;        -- fix#63&#10;        EXECUTE &#39;SELECT setval( &#39;&#39;&#39; || buffer || &#39;&#39;&#39;, &#39; || sq_last_value || &#39;, &#39; || sq_is_called || &#39;);&#39; ;&#10;      END IF;&#10;    END IF;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;   IDENTITIES set:      %&#39;, LPAD(cnt::text, 2, &#39; &#39;);&#10;&#10;&#10;&#10;  -- Issue#78 forces us to defer FKeys until the end since we previously did row copies before FKeys&#10;  --  add FK constraint&#10;  -- action :&#61; &#39;FK Constraints&#39;;&#10;&#10;  -- Issue#62: Add comments on indexes, and then removed them from here and reworked later below.&#10;&#10;  -- Issue 90: moved functions to here, before views or MVs that might use them&#10;  -- Create functions&#10;    action :&#61; &#39;Functions&#39;;&#10;    cnt :&#61; 0;&#10;    -- MJV FIX per issue# 34&#10;    -- SET search_path &#61; &#39;&#39;;&#10;    EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;&#10;    -- Fixed Issue#65&#10;    -- Fixed Issue#97&#10;    -- FOR func_oid IN SELECT oid FROM pg_proc WHERE pronamespace &#61; src_oid AND prokind !&#61; &#39;a&#39;&#10;    IF is_prokind THEN&#10;      FOR func_oid, func_owner, func_name, func_args, func_argno, buffer3 IN&#10;          SELECT p.oid, pg_catalog.pg_get_userbyid(p.proowner), p.proname, oidvectortypes(p.proargtypes), p.pronargs,&#10;          CASE WHEN prokind &#61; &#39;p&#39; THEN &#39;PROCEDURE&#39; WHEN prokind &#61; &#39;f&#39; THEN &#39;FUNCTION&#39; ELSE &#39;&#39; END&#10;          FROM pg_proc p WHERE p.pronamespace &#61; src_oid AND p.prokind !&#61; &#39;a&#39;&#10;      LOOP&#10;        cnt :&#61; cnt + 1;&#10;        SELECT pg_get_functiondef(func_oid)&#10;        INTO qry;&#10;&#10;        SELECT replace(qry, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) INTO dest_qry;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%;&#39;, dest_qry;&#10;          -- Issue#91 Fix&#10;          -- issue#95&#10;          IF NOT bNoOwner THEN&#10;            IF func_argno &#61; 0 THEN&#10;                RAISE INFO &#39;ALTER % %() OWNER TO %&#39;, buffer3, quote_ident(dest_schema) || &#39;.&#39; || quote_ident(func_name), func_owner || &#39;;&#39;;&#10;            ELSE&#10;                RAISE INFO &#39;ALTER % % OWNER TO %&#39;, buffer3, quote_ident(dest_schema) || &#39;.&#39; || quote_ident(func_name) || &#39;(&#39; || func_args || &#39;)&#39;, func_owner || &#39;;&#39;;&#10;            END IF;&#10;          END IF;&#10;        ELSE&#10;          IF bDebug THEN RAISE NOTICE &#39;DEBUG: %&#39;, dest_qry; END IF;&#10;          EXECUTE dest_qry;&#10;&#10;          -- Issue#91 Fix&#10;          -- issue#95&#10;          IF NOT bNoOwner THEN&#10;            IF func_argno &#61; 0 THEN&#10;                dest_qry &#61; &#39;ALTER &#39; || buffer3 || &#39; &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(func_name) || &#39;() OWNER TO &#39; || func_owner || &#39;;&#39;;&#10;            ELSE&#10;                dest_qry &#61; &#39;ALTER &#39; || buffer3 || &#39; &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(func_name) || &#39;(&#39; || func_args || &#39;) OWNER TO &#39; || func_owner || &#39;;&#39;;&#10;            END IF;&#10;          END IF;&#10;          EXECUTE dest_qry;&#10;        END IF;&#10;      END LOOP;&#10;    ELSE&#10;      FOR func_oid IN SELECT oid&#10;                      FROM pg_proc&#10;                      WHERE pronamespace &#61; src_oid AND not proisagg&#10;      LOOP&#10;        cnt :&#61; cnt + 1;&#10;        SELECT pg_get_functiondef(func_oid) INTO qry;&#10;        SELECT replace(qry, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) INTO dest_qry;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%;&#39;, dest_qry;&#10;        ELSE&#10;          EXECUTE dest_qry;&#10;        END IF;&#10;      END LOOP;&#10;    END IF;&#10;&#10;    -- Create aggregate functions.&#10;    -- Fixed Issue#65&#10;    -- FOR func_oid IN SELECT oid FROM pg_proc WHERE pronamespace &#61; src_oid AND prokind &#61; &#39;a&#39;&#10;    IF is_prokind THEN&#10;      FOR func_oid IN&#10;          SELECT oid&#10;          FROM pg_proc&#10;          WHERE pronamespace &#61; src_oid AND prokind &#61; &#39;a&#39;&#10;      LOOP&#10;        cnt :&#61; cnt + 1;&#10;        SELECT&#10;          &#39;CREATE AGGREGATE &#39;&#10;          || dest_schema&#10;          || &#39;.&#39;&#10;          || p.proname&#10;          || &#39;(&#39;&#10;          -- || format_type(a.aggtranstype, NULL)&#10;          -- Issue#65 Fixes for specific datatype mappings&#10;          || CASE WHEN format_type(a.aggtranstype, NULL) &#61; &#39;double precision[]&#39; THEN &#39;float8&#39;&#10;                  WHEN format_type(a.aggtranstype, NULL) &#61; &#39;anyarray&#39;           THEN &#39;anyelement&#39;&#10;             ELSE format_type(a.aggtranstype, NULL) END&#10;          || &#39;) (sfunc &#61; &#39;&#10;          || regexp_replace(a.aggtransfn::text, &#39;(^|\W)&#39; || quote_ident(source_schema) || &#39;\.&#39;, &#39;\1&#39; || quote_ident(dest_schema) || &#39;.&#39;)&#10;          || &#39;, stype &#61; &#39;&#10;          -- || format_type(a.aggtranstype, NULL)&#10;          -- Issue#65 Fixes for specific datatype mappings&#10;          || CASE WHEN format_type(a.aggtranstype, NULL) &#61; &#39;double precision[]&#39; THEN &#39;float8[]&#39; ELSE format_type(a.aggtranstype, NULL) END&#10;          || CASE&#10;              WHEN op.oprname IS NULL THEN &#39;&#39;&#10;              ELSE &#39;, sortop &#61; &#39; || op.oprname&#10;            END&#10;          || CASE&#10;              WHEN a.agginitval IS NULL THEN &#39;&#39;&#10;              ELSE &#39;, initcond &#61; &#39;&#39;&#39; || a.agginitval || &#39;&#39;&#39;&#39;&#10;            END&#10;          || &#39;)&#39;&#10;        INTO dest_qry&#10;        FROM pg_proc p&#10;        JOIN pg_aggregate a ON a.aggfnoid &#61; p.oid&#10;        LEFT JOIN pg_operator op ON op.oid &#61; a.aggsortop&#10;        WHERE p.oid &#61; func_oid;&#10;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%;&#39;, dest_qry;&#10;        ELSE&#10;          EXECUTE dest_qry;&#10;        END IF;&#10;&#10;      END LOOP;&#10;      RAISE NOTICE &#39;   FUNCTIONS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;    ELSE&#10;      FOR func_oid IN SELECT oid FROM pg_proc WHERE pronamespace &#61; src_oid AND proisagg&#10;      LOOP&#10;        cnt :&#61; cnt + 1;&#10;        SELECT&#10;          &#39;CREATE AGGREGATE &#39;&#10;          || dest_schema&#10;          || &#39;.&#39;&#10;          || p.proname&#10;          || &#39;(&#39;&#10;          -- || format_type(a.aggtranstype, NULL)&#10;          -- Issue#65 Fixes for specific datatype mappings&#10;          || CASE WHEN format_type(a.aggtranstype, NULL) &#61; &#39;double precision[]&#39; THEN &#39;float8&#39;&#10;                  WHEN format_type(a.aggtranstype, NULL) &#61; &#39;anyarray&#39;           THEN &#39;anyelement&#39;&#10;             ELSE format_type(a.aggtranstype, NULL) END&#10;          || &#39;) (sfunc &#61; &#39;&#10;          || regexp_replace(a.aggtransfn::text, &#39;(^|\W)&#39; || quote_ident(source_schema) || &#39;\.&#39;, &#39;\1&#39; || quote_ident(dest_schema) || &#39;.&#39;)&#10;          || &#39;, stype &#61; &#39;&#10;          -- || format_type(a.aggtranstype, NULL)&#10;          -- Issue#65 Fixes for specific datatype mappings&#10;          || CASE WHEN format_type(a.aggtranstype, NULL) &#61; &#39;double precision[]&#39; THEN &#39;float8[]&#39; ELSE format_type(a.aggtranstype, NULL) END&#10;          || CASE&#10;              WHEN op.oprname IS NULL THEN &#39;&#39;&#10;              ELSE &#39;, sortop &#61; &#39; || op.oprname&#10;            END&#10;          || CASE&#10;              WHEN a.agginitval IS NULL THEN &#39;&#39;&#10;              ELSE &#39;, initcond &#61; &#39;&#39;&#39; || a.agginitval || &#39;&#39;&#39;&#39;&#10;            END&#10;          || &#39;)&#39;&#10;        INTO dest_qry&#10;        FROM pg_proc p&#10;        JOIN pg_aggregate a ON a.aggfnoid &#61; p.oid&#10;        LEFT JOIN pg_operator op ON op.oid &#61; a.aggsortop&#10;        WHERE p.oid &#61; func_oid;&#10;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%;&#39;, dest_qry;&#10;        ELSE&#10;          EXECUTE dest_qry;&#10;        END IF;&#10;&#10;      END LOOP;&#10;      RAISE NOTICE &#39;   FUNCTIONS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;    END IF;&#10;&#10;  -- Create views&#10;  action :&#61; &#39;Views&#39;;&#10;&#10;  -- Issue#61 FIX: use set_config for empty string&#10;  -- MJV FIX #43: also had to reset search_path from source schema to empty.&#10;  -- SET search_path &#61; &#39;&#39;;&#10;  SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false)&#10;  INTO v_dummy;&#10;&#10;  cnt :&#61; 0;&#10;  --FOR object IN&#10;    -- SELECT table_name::text, view_definition&#10;    -- FROM information_schema.views&#10;    -- WHERE table_schema &#61; quote_ident(source_schema)&#10;&#10;  -- Issue#73 replace loop query to handle dependencies&#10;  -- Issue#91 get view_owner&#10;  FOR srctbl, aname, view_owner, object IN&#10;    WITH RECURSIVE views AS (&#10;       SELECT n.nspname as schemaname, v.relname as tablename, v.oid::regclass AS viewname,&#10;              v.relkind &#61; &#39;m&#39; AS is_materialized, pg_catalog.pg_get_userbyid(v.relowner) as owner,&#10;              1 AS level&#10;       FROM pg_depend AS d&#10;          JOIN pg_rewrite AS r&#10;             ON r.oid &#61; d.objid&#10;          JOIN pg_class AS v&#10;             ON v.oid &#61; r.ev_class&#10;          JOIN pg_namespace n&#10;             ON n.oid &#61; v.relnamespace&#10;       -- WHERE v.relkind IN (&#39;v&#39;, &#39;m&#39;)&#10;       WHERE v.relkind IN (&#39;v&#39;)&#10;         AND d.classid &#61; &#39;pg_rewrite&#39;::regclass&#10;         AND d.refclassid &#61; &#39;pg_class&#39;::regclass&#10;         AND d.deptype &#61; &#39;n&#39;&#10;    UNION&#10;       -- add the views that depend on these&#10;       SELECT n.nspname as schemaname, v.relname as tablename, v.oid::regclass AS viewname,&#10;              v.relkind &#61; &#39;m&#39;, pg_catalog.pg_get_userbyid(v.relowner) as owner,&#10;              views.level + 1&#10;       FROM views&#10;          JOIN pg_depend AS d&#10;             ON d.refobjid &#61; views.viewname&#10;          JOIN pg_rewrite AS r&#10;             ON r.oid &#61; d.objid&#10;          JOIN pg_class AS v&#10;             ON v.oid &#61; r.ev_class&#10;          JOIN pg_namespace n&#10;             ON n.oid &#61; v.relnamespace&#10;       -- WHERE v.relkind IN (&#39;v&#39;, &#39;m&#39;)&#10;       WHERE v.relkind IN (&#39;v&#39;)&#10;         AND d.classid &#61; &#39;pg_rewrite&#39;::regclass&#10;             AND d.refclassid &#61; &#39;pg_class&#39;::regclass&#10;         AND d.deptype &#61; &#39;n&#39;&#10;         AND v.oid &lt;&gt; views.viewname&#10;    )&#10;    SELECT tablename, viewname, owner, format(&#39;CREATE OR REPLACE%s VIEW %s AS%s&#39;,&#10;                  CASE WHEN is_materialized&#10;                       THEN &#39; MATERIALIZED&#39;&#10;                       ELSE &#39;&#39;&#10;                  END,&#10;                  viewname,&#10;                  pg_get_viewdef(viewname))&#10;    FROM views&#10;    WHERE schemaname &#61; quote_ident(source_schema)&#10;    GROUP BY schemaname, tablename, viewname, owner, is_materialized&#10;    ORDER BY max(level), schemaname, tablename&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    -- Issue#73 replace logic based on new loop sql&#10;    buffer :&#61; quote_ident(dest_schema) || &#39;.&#39; || quote_ident(aname);&#10;    -- MJV FIX: #43&#10;    -- SELECT view_definition INTO v_def&#10;    -- SELECT REPLACE(view_definition, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) INTO v_def&#10;    -- FROM information_schema.views&#10;    -- WHERE table_schema &#61; quote_ident(source_schema)&#10;    --   AND table_name &#61; quote_ident(object);&#10;    SELECT REPLACE(object, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) INTO v_def;&#10;    -- NOTE: definition already includes the closing statement semicolon&#10;    SELECT REPLACE(aname, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) INTO buffer3;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, v_def;&#10;      -- Issue#91 Fix&#10;      -- issue#95&#10;      IF NOT bNoOwner THEN&#10;        RAISE INFO &#39;ALTER TABLE % OWNER TO %&#39;, buffer3, view_owner || &#39;;&#39;;&#10;      END IF;&#10;    ELSE&#10;      -- EXECUTE &#39;CREATE OR REPLACE VIEW &#39; || buffer || &#39; AS &#39; || v_def;&#10;      EXECUTE v_def;&#10;      -- Issue#73: commented out comment logic for views since we do it elsewhere now.&#10;      -- Issue#91 Fix&#10;      -- issue#95&#10;      IF NOT bNoOwner THEN&#10;        v_def &#61; &#39;ALTER TABLE &#39; || buffer3 || &#39; OWNER TO &#39; || view_owner || &#39;;&#39;;&#10;        EXECUTE v_def;&#10;      END IF;&#10;    END IF;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;       VIEWS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  -- Create Materialized views&#10;  action :&#61; &#39;Mat. Views&#39;;&#10;  cnt :&#61; 0;&#10;  -- Issue#91 get view_owner&#10;  FOR object, view_owner, v_def IN&#10;      SELECT matviewname::text, matviewowner::text, replace(definition,&#39;;&#39;,&#39;&#39;) FROM pg_catalog.pg_matviews WHERE schemaname &#61; quote_ident(source_schema)&#10;  LOOP&#10;      cnt :&#61; cnt + 1;&#10;      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on target schema and object&#10;      buffer :&#61; quote_ident(dest_schema) || &#39;.&#39; || quote_ident(object);&#10;&#10;      -- MJV FIX: #72 remove source schema in MV def&#10;      SELECT REPLACE(v_def, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) INTO buffer2;&#10;&#10;      IF bData THEN&#10;        -- issue#98 defer creation until after regular tables are populated. Also defer the ownership as well.&#10;        -- EXECUTE &#39;CREATE MATERIALIZED VIEW &#39; || buffer || &#39; AS &#39; || buffer2 || &#39; WITH DATA;&#39; ;&#10;        buffer3 &#61; &#39;CREATE MATERIALIZED VIEW &#39; || buffer || &#39; AS &#39; || buffer2 || &#39; WITH DATA;&#39;;&#10;        mvarray :&#61; mvarray || buffer3;&#10;&#10;        -- issue#95&#10;        IF NOT bNoOwner THEN&#10;          -- buffer3 &#61; &#39;ALTER MATERIALIZED VIEW &#39; || buffer || &#39; OWNER TO &#39; || view_owner || &#39;;&#39; ;&#10;          -- EXECUTE buffer3;&#10;          buffer3 &#61; &#39;ALTER MATERIALIZED VIEW &#39; || buffer || &#39; OWNER TO &#39; || view_owner || &#39;;&#39; ;&#10;          mvarray :&#61; mvarray || buffer3;&#10;        END IF;&#10;      ELSE&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, &#39;CREATE MATERIALIZED VIEW &#39; || buffer || &#39; AS &#39; || buffer2 || &#39; WITH NO DATA;&#39; ;&#10;          -- Issue#91&#10;          -- issue#95&#10;          IF NOT bNoOwner THEN&#10;            RAISE INFO &#39;%&#39;, &#39;ALTER MATERIALIZED VIEW &#39; || buffer || &#39; OWNER TO &#39; || view_owner || &#39;;&#39; ;&#10;          END IF;&#10;        ELSE&#10;          EXECUTE &#39;CREATE MATERIALIZED VIEW &#39; || buffer || &#39; AS &#39; || buffer2 || &#39; WITH NO DATA;&#39; ;&#10;          -- Issue#91&#10;          -- issue#95&#10;          IF NOT bNoOwner THEN&#10;            buffer3 &#61; &#39;ALTER MATERIALIZED VIEW &#39; || buffer || &#39; OWNER TO &#39; || view_owner || &#39;;&#39; ;&#10;            EXECUTE buffer3;&#10;          END IF;&#10;        END IF;&#10;      END IF;&#10;      SELECT coalesce(obj_description(oid), &#39;&#39;) into adef from pg_class where relkind &#61; &#39;m&#39; and relname &#61; object;&#10;      IF adef &lt;&gt; &#39;&#39; THEN&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, &#39;COMMENT ON MATERIALIZED VIEW &#39; || quote_ident(dest_schema) || &#39;.&#39; || object || &#39; IS &#39;&#39;&#39; || adef || &#39;&#39;&#39;;&#39;;&#10;        ELSE&#10;          -- Issue#$98: also defer if copy rows is on since we defer MVIEWS in that case&#10;          IF bData THEN&#10;            buffer3 &#61; &#39;COMMENT ON MATERIALIZED VIEW &#39; || quote_ident(dest_schema) || &#39;.&#39; || object || &#39; IS &#39;&#39;&#39; || adef || &#39;&#39;&#39;;&#39;;&#10;            mvarray &#61; mvarray || buffer3;&#10;          ELSE&#10;            EXECUTE &#39;COMMENT ON MATERIALIZED VIEW &#39; || quote_ident(dest_schema) || &#39;.&#39; || object || &#39; IS &#39;&#39;&#39; || adef || &#39;&#39;&#39;;&#39;;&#10;          END IF;&#10;&#10;        END IF;&#10;      END IF;&#10;&#10;      FOR aname, adef IN&#10;        SELECT indexname, replace(indexdef, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;) as newdef FROM pg_indexes where schemaname &#61; quote_ident(source_schema) and tablename &#61; object order by indexname&#10;      LOOP&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, adef || &#39;;&#39;;&#10;        ELSE&#10;          EXECUTE adef || &#39;;&#39;;&#10;        END IF;&#10;      END LOOP;&#10;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;   MAT VIEWS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  -- Issue 90 Move create functions to before views&#10;&#10;  -- MV: Create Triggers&#10;&#10;  -- MJV FIX: #38&#10;  -- EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;&#10;  -- Issue#61 FIX: use set_config for empty string&#10;  -- SET search_path &#61; &#39;&#39;;&#10;  SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false) into v_dummy;&#10;&#10;  action :&#61; &#39;Triggers&#39;;&#10;  cnt :&#61; 0;&#10;  FOR arec IN&#10;    -- 2021-03-09 MJV FIX: #40 fixed sql to get the def using pg_get_triggerdef() sql&#10;    SELECT n.nspname, c.relname, t.tgname, p.proname, REPLACE(pg_get_triggerdef(t.oid), quote_ident(source_schema), quote_ident(dest_schema)) || &#39;;&#39; AS trig_ddl&#10;    FROM pg_trigger t, pg_class c, pg_namespace n, pg_proc p&#10;    WHERE n.nspname &#61; quote_ident(source_schema)&#10;      AND n.oid &#61; c.relnamespace&#10;      AND c.relkind in (&#39;r&#39;,&#39;p&#39;)&#10;      AND n.oid &#61; p.pronamespace&#10;      AND c.oid &#61; t.tgrelid&#10;      AND p.oid &#61; t.tgfoid&#10;      ORDER BY c.relname, t.tgname&#10;  LOOP&#10;    BEGIN&#10;      cnt :&#61; cnt + 1;&#10;      IF bDDLOnly THEN&#10;        RAISE INFO &#39;%&#39;, arec.trig_ddl;&#10;      ELSE&#10;        EXECUTE arec.trig_ddl;&#10;      END IF;&#10;&#10;    END;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;    TRIGGERS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;&#10;  -- MV: Create Rules&#10;  -- Fixes Issue#59 Implement Rules&#10;  action :&#61; &#39;Rules&#39;;&#10;  cnt :&#61; 0;&#10;  FOR arec IN&#10;    SELECT regexp_replace(definition, E&#39;[\\n\\r]+&#39;, &#39; &#39;, &#39;g&#39; ) as definition&#10;    FROM pg_rules&#10;    WHERE schemaname &#61; quote_ident(source_schema)&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    buffer :&#61; REPLACE(arec.definition, quote_ident(source_schema) || &#39;.&#39;, quote_ident(dest_schema) || &#39;.&#39;);&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, buffer;&#10;    ELSE&#10;      EXECUTE buffer;&#10;    END IF;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;    RULES    cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;&#10;  -- MV: Create Policies&#10;  -- Fixes Issue#66 Implement Security policies for RLS&#10;  action :&#61; &#39;Policies&#39;;&#10;  cnt :&#61; 0;&#10;  FOR arec IN&#10;    -- Issue#78 FIX: handle case-sensitive names with quote_ident() on policy, tablename&#10;    SELECT schemaname as schemaname, tablename as tablename, &#39;CREATE POLICY &#39; || policyname || &#39; ON &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tablename) || &#39; AS &#39; || permissive || &#39; FOR &#39; || cmd || &#39; TO &#39;&#10;    ||  array_to_string(roles, &#39;,&#39;, &#39;*&#39;) || &#39; USING (&#39; || regexp_replace(qual, E&#39;[\\n\\r]+&#39;, &#39; &#39;, &#39;g&#39; ) || &#39;)&#39;&#10;    || CASE WHEN with_check IS NOT NULL THEN &#39; WITH CHECK (&#39; ELSE &#39;&#39; END || coalesce(with_check, &#39;&#39;) || CASE WHEN with_check IS NOT NULL THEN &#39;);&#39; ELSE &#39;;&#39; END as definition&#10;    FROM pg_policies&#10;    WHERE schemaname &#61; quote_ident(source_schema)&#10;    ORDER BY policyname&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, arec.definition;&#10;    ELSE&#10;      EXECUTE arec.definition;&#10;    END IF;&#10;&#10;    -- Issue#76: Enable row security if indicated&#10;    SELECT c.relrowsecurity INTO abool FROM pg_class c, pg_namespace n where n.nspname &#61; quote_ident(arec.schemaname) AND n.oid &#61; c.relnamespace AND c.relname &#61; quote_ident(arec.tablename) and c.relkind &#61; &#39;r&#39;;&#10;    IF abool THEN&#10;      buffer &#61; &#39;ALTER TABLE &#39; || dest_schema || &#39;.&#39; || arec.tablename || &#39; ENABLE ROW LEVEL SECURITY;&#39;;&#10;      IF bDDLOnly THEN&#10;        RAISE INFO &#39;%&#39;, buffer;&#10;      ELSE&#10;        EXECUTE buffer;&#10;      END IF;&#10;    END IF;&#10;  END LOOP;&#10;  RAISE NOTICE &#39;    POLICIES cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;&#10;  -- MJV Fixed #62 for comments (PASS 1)&#10;  action :&#61; &#39;Comments1&#39;;&#10;  cnt :&#61; 0;&#10;  FOR qry IN&#10;    -- Issue#74 Fix: Change schema from source to target. Also, do not include comments on foreign tables since we do not clone foreign tables at this time.&#10;    SELECT &#39;COMMENT ON &#39; || CASE WHEN c.relkind in (&#39;r&#39;,&#39;p&#39;) AND a.attname IS NULL THEN &#39;TABLE &#39; WHEN c.relkind in (&#39;r&#39;,&#39;p&#39;) AND&#10;    a.attname IS NOT NULL THEN &#39;COLUMN &#39; WHEN c.relkind &#61; &#39;f&#39; THEN &#39;FOREIGN TABLE &#39; WHEN c.relkind &#61; &#39;m&#39; THEN &#39;MATERIALIZED VIEW &#39; WHEN c.relkind &#61; &#39;v&#39; THEN &#39;VIEW &#39;&#10;    WHEN c.relkind &#61; &#39;i&#39; THEN &#39;INDEX &#39; WHEN c.relkind &#61; &#39;S&#39; THEN &#39;SEQUENCE &#39; ELSE &#39;XX&#39; END || quote_ident(dest_schema) || &#39;.&#39; || CASE WHEN c.relkind in (&#39;r&#39;,&#39;p&#39;) AND&#10;    -- Issue#78: handle case-sensitive names with quote_ident()&#10;    a.attname IS NOT NULL THEN quote_ident(c.relname) || &#39;.&#39; || a.attname ELSE quote_ident(c.relname) END ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_class c&#10;    JOIN pg_namespace n ON (n.oid &#61; c.relnamespace)&#10;    LEFT JOIN pg_description d ON (c.oid &#61; d.objoid)&#10;    LEFT JOIN pg_attribute a ON (c.oid &#61; a.attrelid&#10;      AND a.attnum &gt; 0 and a.attnum &#61; d.objsubid)&#10;    WHERE c.relkind &lt;&gt; &#39;f&#39; AND d.description IS NOT NULL AND n.nspname &#61; quote_ident(source_schema)&#10;    ORDER BY ddl&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;&#10;    -- BAD : &quot;COMMENT ON SEQUENCE sample_clone2.CaseSensitive_ID_seq IS &#39;just a comment on CaseSensitive sequence&#39;;&quot;&#10;    -- GOOD: &quot;COMMENT ON SEQUENCE &quot;CaseSensitive_ID_seq&quot; IS &#39;just a comment on CaseSensitive sequence&#39;;&quot;&#10;&#10;    -- Issue#98 For MVs we create comments when we create the MVs&#10;    IF substring(qry,1,28) &#61; &#39;COMMENT ON MATERIALIZED VIEW&#39; THEN&#10;      IF bDebug THEN RAISE NOTICE &#39;DEBUG: deferring comments on MVs&#39;; END IF;&#10;      cnt &#61; cnt - 1;&#10;      continue;&#10;    END IF;&#10;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, qry;&#10;    ELSE&#10;      EXECUTE qry;&#10;    END IF;&#10;  END LOOP;&#10;  RAISE NOTICE &#39; COMMENTS(1) cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;  -- MJV Fixed #62 for comments (PASS 2)&#10;  action :&#61; &#39;Comments2&#39;;&#10;  cnt2 :&#61; 0;&#10;  IF is_prokind THEN&#10;  FOR qry IN&#10;    -- Issue#74 Fix: Change schema from source to target.&#10;    SELECT &#39;COMMENT ON SCHEMA &#39; || dest_schema ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    from pg_namespace n, pg_description d where d.objoid &#61; n.oid and n.nspname &#61; quote_ident(source_schema)&#10;    UNION&#10;    -- Issue#74 Fix: need to replace source schema inline&#10;    -- SELECT &#39;COMMENT ON TYPE &#39; || pg_catalog.format_type(t.oid, NULL) || &#39; IS &#39;&#39;&#39; || pg_catalog.obj_description(t.oid, &#39;pg_type&#39;) || &#39;&#39;&#39;;&#39; as ddl&#10;    SELECT &#39;COMMENT ON TYPE &#39; || REPLACE(pg_catalog.format_type(t.oid, NULL), quote_ident(source_schema), quote_ident(dest_schema)) || &#39; IS &#39;&#39;&#39; || pg_catalog.obj_description(t.oid, &#39;pg_type&#39;) || &#39;&#39;&#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_type t&#10;    JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;    WHERE (t.typrelid &#61; 0 OR (SELECT c.relkind &#61; &#39;c&#39; FROM pg_catalog.pg_class c WHERE c.oid &#61; t.typrelid))&#10;      AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid &#61; t.typelem AND el.typarray &#61; t.oid)&#10;      AND n.nspname &#61; quote_ident(source_schema) COLLATE pg_catalog.default&#10;      AND pg_catalog.obj_description(t.oid, &#39;pg_type&#39;) IS NOT NULL and t.typtype &#61; &#39;c&#39;&#10;    UNION&#10;    -- Issue#78: handle case-sensitive names with quote_ident()&#10;    SELECT &#39;COMMENT ON COLLATION &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(c.collname) || &#39; IS &#39;&#39;&#39; || pg_catalog.obj_description(c.oid, &#39;pg_collation&#39;) || &#39;&#39;&#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n&#10;    WHERE n.oid &#61; c.collnamespace AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))&#10;      AND n.nspname &#61; quote_ident(source_schema) COLLATE pg_catalog.default AND pg_catalog.obj_description(c.oid, &#39;pg_collation&#39;) IS NOT NULL&#10;    UNION&#10;    SELECT &#39;COMMENT ON &#39; || CASE WHEN p.prokind &#61; &#39;f&#39; THEN &#39;FUNCTION &#39; WHEN p.prokind &#61; &#39;p&#39; THEN &#39;PROCEDURE &#39; WHEN p.prokind &#61; &#39;a&#39; THEN &#39;AGGREGATE &#39; END ||&#10;    dest_schema || &#39;.&#39; || p.proname || &#39; (&#39; || oidvectortypes(p.proargtypes) || &#39;)&#39;&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_namespace n&#10;    JOIN pg_catalog.pg_proc p ON p.pronamespace &#61; n.oid&#10;    JOIN pg_description d ON (d.objoid &#61; p.oid)&#10;    WHERE n.nspname &#61; quote_ident(source_schema)&#10;    UNION&#10;    SELECT &#39;COMMENT ON POLICY &#39; || p1.policyname || &#39; ON &#39; || dest_schema || &#39;.&#39; || p1.tablename ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_policies p1, pg_policy p2, pg_class c, pg_namespace n, pg_description d&#10;    WHERE p1.schemaname &#61; n.nspname AND p1.tablename &#61; c.relname AND n.oid &#61; c.relnamespace&#10;      AND c.relkind in (&#39;r&#39;,&#39;p&#39;) AND p1.policyname &#61; p2.polname AND d.objoid &#61; p2.oid AND p1.schemaname &#61; quote_ident(source_schema)&#10;    UNION&#10;    SELECT &#39;COMMENT ON DOMAIN &#39; || dest_schema || &#39;.&#39; || t.typname ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_type t&#10;    LEFT JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;    JOIN pg_catalog.pg_description d ON d.classoid &#61; t.tableoid AND d.objoid &#61; t.oid AND d.objsubid &#61; 0&#10;    WHERE t.typtype &#61; &#39;d&#39; AND n.nspname &#61; quote_ident(source_schema) COLLATE pg_catalog.default&#10;    ORDER BY 1&#10;  LOOP&#10;    cnt2 :&#61; cnt2 + 1;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, qry;&#10;    ELSE&#10;      EXECUTE qry;&#10;    END IF;&#10;  END LOOP;&#10;  ELSE -- must be v 10 or less&#10;  FOR qry IN&#10;    -- Issue#74 Fix: Change schema from source to target.&#10;    SELECT &#39;COMMENT ON SCHEMA &#39; || dest_schema ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    from pg_namespace n, pg_description d where d.objoid &#61; n.oid and n.nspname &#61; quote_ident(source_schema)&#10;    UNION&#10;    -- Issue#74 Fix: need to replace source schema inline&#10;    -- SELECT &#39;COMMENT ON TYPE &#39; || pg_catalog.format_type(t.oid, NULL) || &#39; IS &#39;&#39;&#39; || pg_catalog.obj_description(t.oid, &#39;pg_type&#39;) || &#39;&#39;&#39;;&#39; as ddl&#10;    SELECT &#39;COMMENT ON TYPE &#39; || REPLACE(pg_catalog.format_type(t.oid, NULL), quote_ident(source_schema), quote_ident(dest_schema)) || &#39; IS &#39;&#39;&#39; || pg_catalog.obj_description(t.oid, &#39;pg_type&#39;) || &#39;&#39;&#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_type t&#10;    JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;    WHERE (t.typrelid &#61; 0 OR (SELECT c.relkind &#61; &#39;c&#39;&#10;                              FROM pg_catalog.pg_class c&#10;                              WHERE c.oid &#61; t.typrelid))&#10;      AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el&#10;                     WHERE el.oid &#61; t.typelem AND el.typarray &#61; t.oid)&#10;      AND n.nspname &#61; quote_ident(source_schema) COLLATE pg_catalog.default&#10;      AND pg_catalog.obj_description(t.oid, &#39;pg_type&#39;) IS NOT NULL and t.typtype &#61; &#39;c&#39;&#10;    UNION&#10;    -- FIX Isse#87 by adding double quotes around collation name&#10;    SELECT &#39;COMMENT ON COLLATION &#39; || dest_schema || &#39;.&quot;&#39; || c.collname || &#39;&quot; IS &#39;&#39;&#39; || pg_catalog.obj_description(c.oid, &#39;pg_collation&#39;) || &#39;&#39;&#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n&#10;    WHERE n.oid &#61; c.collnamespace AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))&#10;      AND n.nspname &#61; quote_ident(source_schema) COLLATE pg_catalog.default AND pg_catalog.obj_description(c.oid, &#39;pg_collation&#39;) IS NOT NULL&#10;    UNION&#10;    SELECT &#39;COMMENT ON &#39; || CASE WHEN proisagg THEN &#39;AGGREGATE &#39; ELSE &#39;FUNCTION &#39; END ||&#10;    dest_schema || &#39;.&#39; || p.proname || &#39; (&#39; || oidvectortypes(p.proargtypes) || &#39;)&#39;&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_namespace n&#10;    JOIN pg_catalog.pg_proc p ON p.pronamespace &#61; n.oid&#10;    JOIN pg_description d ON (d.objoid &#61; p.oid)&#10;    WHERE n.nspname &#61; quote_ident(source_schema)&#10;    UNION&#10;    SELECT &#39;COMMENT ON POLICY &#39; || p1.policyname || &#39; ON &#39; || dest_schema || &#39;.&#39; || p1.tablename ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_policies p1, pg_policy p2, pg_class c, pg_namespace n, pg_description d&#10;    WHERE p1.schemaname &#61; n.nspname AND p1.tablename &#61; c.relname AND n.oid &#61; c.relnamespace&#10;      AND c.relkind in (&#39;r&#39;,&#39;p&#39;) AND p1.policyname &#61; p2.polname AND d.objoid &#61; p2.oid AND p1.schemaname &#61; quote_ident(source_schema)&#10;    UNION&#10;    SELECT &#39;COMMENT ON DOMAIN &#39; || dest_schema || &#39;.&#39; || t.typname ||&#10;    -- Issue#74 Fix&#10;    -- &#39; IS &#39;&#39;&#39; || d.description || &#39;&#39;&#39;;&#39; as ddl&#10;    &#39; IS &#39;   || quote_literal(d.description) || &#39;;&#39; as ddl&#10;    FROM pg_catalog.pg_type t&#10;    LEFT JOIN pg_catalog.pg_namespace n ON n.oid &#61; t.typnamespace&#10;    JOIN pg_catalog.pg_description d ON d.classoid &#61; t.tableoid AND d.objoid &#61; t.oid AND d.objsubid &#61; 0&#10;    WHERE t.typtype &#61; &#39;d&#39; AND n.nspname &#61; quote_ident(source_schema) COLLATE pg_catalog.default&#10;    ORDER BY 1&#10;  LOOP&#10;    cnt2 :&#61; cnt2 + 1;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, qry;&#10;    ELSE&#10;      EXECUTE qry;&#10;    END IF;&#10;  END LOOP;&#10;  END IF;&#10;  RAISE NOTICE &#39; COMMENTS(2) cloned: %&#39;, LPAD(cnt2::text, 5, &#39; &#39;);&#10;&#10;&#10;  -- Issue#95 bypass if No ACL specified.&#10;  IF NOT bNoACL THEN&#10;    -- ---------------------&#10;    -- MV: Permissions: Defaults&#10;    -- ---------------------&#10;    EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;    action :&#61; &#39;PRIVS: Defaults&#39;;&#10;    cnt :&#61; 0;&#10;    FOR arec IN&#10;      SELECT pg_catalog.pg_get_userbyid(d.defaclrole) AS &quot;owner&quot;, n.nspname AS schema,&#10;      CASE d.defaclobjtype WHEN &#39;r&#39; THEN &#39;table&#39; WHEN &#39;S&#39; THEN &#39;sequence&#39; WHEN &#39;f&#39; THEN &#39;function&#39; WHEN &#39;T&#39; THEN &#39;type&#39; WHEN &#39;n&#39; THEN &#39;schema&#39; END AS atype,&#10;      d.defaclacl as defaclacl, pg_catalog.array_to_string(d.defaclacl, &#39;,&#39;) as defaclstr&#10;      FROM pg_catalog.pg_default_acl d LEFT JOIN pg_catalog.pg_namespace n ON (n.oid &#61; d.defaclnamespace)&#10;      WHERE n.nspname IS NOT NULL AND n.nspname &#61; quote_ident(source_schema)&#10;      ORDER BY 3, 2, 1&#10;    LOOP&#10;      BEGIN&#10;        -- RAISE NOTICE &#39; owner&#61;%  type&#61;%  defaclacl&#61;%  defaclstr&#61;%&#39;, arec.owner, arec.atype, arec.defaclacl, arec.defaclstr;&#10;&#10;        FOREACH aclstr IN ARRAY arec.defaclacl&#10;        LOOP&#10;            cnt :&#61; cnt + 1;&#10;            -- RAISE NOTICE &#39; aclstr&#61;%&#39;, aclstr;&#10;            -- break up into grantor, grantee, and privs, mydb_update&#61;rwU/mydb_owner&#10;            SELECT split_part(aclstr, &#39;&#61;&#39;,1) INTO grantee;&#10;            SELECT split_part(aclstr, &#39;&#61;&#39;,2) INTO grantor;&#10;            SELECT split_part(grantor, &#39;/&#39;,1) INTO privs;&#10;            SELECT split_part(grantor, &#39;/&#39;,2) INTO grantor;&#10;            -- RAISE NOTICE &#39; grantor&#61;%  grantee&#61;%  privs&#61;%&#39;, grantor, grantee, privs;&#10;&#10;            IF arec.atype &#61; &#39;function&#39; THEN&#10;              -- Just having execute is enough to grant all apparently.&#10;              buffer :&#61; &#39;ALTER DEFAULT PRIVILEGES FOR ROLE &#39; || grantor || &#39; IN SCHEMA &#39; || quote_ident(dest_schema) || &#39; GRANT ALL ON FUNCTIONS TO &quot;&#39; || grantee || &#39;&quot;;&#39;;&#10;&#10;              -- Issue#92 Fix&#10;              -- set role &#61; cm_stage_ro_grp;&#10;              -- ALTER DEFAULT PRIVILEGES FOR ROLE cm_stage_ro_grp IN SCHEMA cm_stage GRANT REFERENCES, TRIGGER ON TABLES TO cm_stage_ro_grp;&#10;              IF grantor &#61; grantee THEN&#10;                  -- append set role to statement&#10;                  buffer &#61; &#39;SET ROLE &#61; &#39; || grantor || &#39;; &#39; || buffer;&#10;              END IF;&#10;&#10;              IF bDDLOnly THEN&#10;                RAISE INFO &#39;%&#39;, buffer;&#10;              ELSE&#10;                EXECUTE buffer;&#10;              END IF;&#10;              -- Issue#92 Fix:&#10;              EXECUTE &#39;SET ROLE &#61; &#39; || calleruser;&#10;&#10;            ELSIF arec.atype &#61; &#39;sequence&#39; THEN&#10;              IF POSITION(&#39;r&#39; IN privs) &gt; 0 AND POSITION(&#39;w&#39; IN privs) &gt; 0 AND POSITION(&#39;U&#39; IN privs) &gt; 0 THEN&#10;                -- arU is enough for all privs&#10;                buffer :&#61; &#39;ALTER DEFAULT PRIVILEGES FOR ROLE &#39; || grantor || &#39; IN SCHEMA &#39; || quote_ident(dest_schema) || &#39; GRANT ALL ON SEQUENCES TO &quot;&#39; || grantee || &#39;&quot;;&#39;;&#10;&#10;                -- Issue#92 Fix&#10;                IF grantor &#61; grantee THEN&#10;                    -- append set role to statement&#10;                    buffer &#61; &#39;SET ROLE &#61; &#39; || grantor || &#39;; &#39; || buffer;&#10;                END IF;&#10;&#10;                IF bDDLOnly THEN&#10;                  RAISE INFO &#39;%&#39;, buffer;&#10;                ELSE&#10;                  EXECUTE buffer;&#10;                END IF;&#10;                -- Issue#92 Fix:&#10;                EXECUTE &#39;SET ROLE &#61; &#39; || calleruser;&#10;&#10;              ELSE&#10;                -- have to specify each priv individually&#10;                buffer2 :&#61; &#39;&#39;;&#10;                IF POSITION(&#39;r&#39; IN privs) &gt; 0 THEN&#10;                      buffer2 :&#61; &#39;SELECT&#39;;&#10;                END IF;&#10;                IF POSITION(&#39;w&#39; IN privs) &gt; 0 THEN&#10;                  IF buffer2 &#61; &#39;&#39; THEN&#10;                    buffer2 :&#61; &#39;UPDATE&#39;;&#10;                  ELSE&#10;                    buffer2 :&#61; buffer2 || &#39;, UPDATE&#39;;&#10;                  END IF;&#10;                END IF;&#10;                IF POSITION(&#39;U&#39; IN privs) &gt; 0 THEN&#10;                      IF buffer2 &#61; &#39;&#39; THEN&#10;                    buffer2 :&#61; &#39;USAGE&#39;;&#10;                  ELSE&#10;                    buffer2 :&#61; buffer2 || &#39;, USAGE&#39;;&#10;                  END IF;&#10;                END IF;&#10;                buffer :&#61; &#39;ALTER DEFAULT PRIVILEGES FOR ROLE &#39; || grantor || &#39; IN SCHEMA &#39; || quote_ident(dest_schema) || &#39; GRANT &#39; || buffer2 || &#39; ON SEQUENCES TO &quot;&#39; || grantee || &#39;&quot;;&#39;;&#10;&#10;                -- Issue#92 Fix&#10;                IF grantor &#61; grantee THEN&#10;                    -- append set role to statement&#10;                    buffer &#61; &#39;SET ROLE &#61; &#39; || grantor || &#39;; &#39; || buffer;&#10;                END IF;&#10;&#10;                IF bDDLOnly THEN&#10;                  RAISE INFO &#39;%&#39;, buffer;&#10;                ELSE&#10;                  EXECUTE buffer;&#10;                END IF;&#10;                select current_user into buffer;&#10;                -- Issue#92 Fix:&#10;                EXECUTE &#39;SET ROLE &#61; &#39; || calleruser;&#10;              END IF;&#10;&#10;            ELSIF arec.atype &#61; &#39;table&#39; THEN&#10;              -- do each priv individually, jeeeesh!&#10;              buffer2 :&#61; &#39;&#39;;&#10;              IF POSITION(&#39;a&#39; IN privs) &gt; 0 THEN&#10;                buffer2 :&#61; &#39;INSERT&#39;;&#10;              END IF;&#10;              IF POSITION(&#39;r&#39; IN privs) &gt; 0 THEN&#10;                IF buffer2 &#61; &#39;&#39; THEN&#10;                  buffer2 :&#61; &#39;SELECT&#39;;&#10;                ELSE&#10;                  buffer2 :&#61; buffer2 || &#39;, SELECT&#39;;&#10;                END IF;&#10;              END IF;&#10;              IF POSITION(&#39;w&#39; IN privs) &gt; 0 THEN&#10;                IF buffer2 &#61; &#39;&#39; THEN&#10;                  buffer2 :&#61; &#39;UPDATE&#39;;&#10;                ELSE&#10;                  buffer2 :&#61; buffer2 || &#39;, UPDATE&#39;;&#10;                END IF;&#10;              END IF;&#10;              IF POSITION(&#39;d&#39; IN privs) &gt; 0 THEN&#10;                IF buffer2 &#61; &#39;&#39; THEN&#10;                  buffer2 :&#61; &#39;DELETE&#39;;&#10;                ELSE&#10;                  buffer2 :&#61; buffer2 || &#39;, DELETE&#39;;&#10;                END IF;&#10;              END IF;&#10;              IF POSITION(&#39;t&#39; IN privs) &gt; 0 THEN&#10;                IF buffer2 &#61; &#39;&#39; THEN&#10;                  buffer2 :&#61; &#39;TRIGGER&#39;;&#10;                ELSE&#10;                  buffer2 :&#61; buffer2 || &#39;, TRIGGER&#39;;&#10;                END IF;&#10;              END IF;&#10;              IF POSITION(&#39;T&#39; IN privs) &gt; 0 THEN&#10;                IF buffer2 &#61; &#39;&#39; THEN&#10;                  buffer2 :&#61; &#39;TRUNCATE&#39;;&#10;                ELSE&#10;                  buffer2 :&#61; buffer2 || &#39;, TRUNCATE&#39;;&#10;                END IF;&#10;              END IF;&#10;              buffer :&#61; &#39;ALTER DEFAULT PRIVILEGES FOR ROLE &#39; || grantor || &#39; IN SCHEMA &#39; || quote_ident(dest_schema) || &#39; GRANT &#39; || buffer2 || &#39; ON TABLES TO &quot;&#39; || grantee || &#39;&quot;;&#39;;&#10;&#10;              -- Issue#92 Fix&#10;              IF grantor &#61; grantee THEN&#10;                  -- append set role to statement&#10;                  buffer &#61; &#39;SET ROLE &#61; &#39; || grantor || &#39;; &#39; || buffer;&#10;              END IF;&#10;&#10;              IF bDDLOnly THEN&#10;                RAISE INFO &#39;%&#39;, buffer;&#10;              ELSE&#10;                EXECUTE buffer;&#10;              END IF;&#10;              select current_user into buffer;&#10;              -- Issue#92 Fix:&#10;              EXECUTE &#39;SET ROLE &#61; &#39; || calleruser;&#10;&#10;            ELSIF arec.atype &#61; &#39;type&#39; THEN&#10;              IF POSITION(&#39;r&#39; IN privs) &gt; 0 AND POSITION(&#39;w&#39; IN privs) &gt; 0 AND POSITION(&#39;U&#39; IN privs) &gt; 0 THEN&#10;                -- arU is enough for all privs&#10;                buffer :&#61; &#39;ALTER DEFAULT PRIVILEGES FOR ROLE &#39; || grantor || &#39; IN SCHEMA &#39; || quote_ident(dest_schema) || &#39; GRANT ALL ON TYPES TO &quot;&#39; || grantee || &#39;&quot;;&#39;;&#10;&#10;                -- Issue#92 Fix&#10;                IF grantor &#61; grantee THEN&#10;                    -- append set role to statement&#10;                    buffer &#61; &#39;SET ROLE &#61; &#39; || grantor || &#39;; &#39; || buffer;&#10;                END IF;&#10;&#10;                IF bDDLOnly THEN&#10;                  RAISE INFO &#39;%&#39;, buffer;&#10;                ELSE&#10;                  EXECUTE buffer;&#10;                END IF;&#10;                -- Issue#92 Fix:&#10;                EXECUTE &#39;SET ROLE &#61; &#39; || calleruser;&#10;&#10;              ELSIF POSITION(&#39;U&#39; IN privs) THEN&#10;                buffer :&#61; &#39;ALTER DEFAULT PRIVILEGES FOR ROLE &#39; || grantor || &#39; IN SCHEMA &#39; || quote_ident(dest_schema) || &#39; GRANT USAGE ON TYPES TO &quot;&#39; || grantee || &#39;&quot;;&#39;;&#10;&#10;                -- Issue#92 Fix&#10;                IF grantor &#61; grantee THEN&#10;                    -- append set role to statement&#10;                    buffer &#61; &#39;SET ROLE &#61; &#39; || grantor || &#39;; &#39; || buffer;&#10;                END IF;&#10;&#10;                IF bDDLOnly THEN&#10;                  RAISE INFO &#39;%&#39;, buffer;&#10;                ELSE&#10;                  EXECUTE buffer;&#10;                END IF;&#10;                -- Issue#92 Fix:&#10;                EXECUTE &#39;SET ROLE &#61; &#39; || calleruser;&#10;&#10;              ELSE&#10;                RAISE WARNING &#39;Unhandled TYPE Privs:: type&#61;%  privs&#61;%  owner&#61;%   defaclacl&#61;%  defaclstr&#61;%  grantor&#61;%  grantee&#61;% &#39;, arec.atype, privs, arec.owner, arec.defaclacl, arec.defaclstr, grantor, grantee;&#10;            END IF;&#10;          ELSE&#10;            RAISE WARNING &#39;Unhandled Privs:: type&#61;%  privs&#61;%  owner&#61;%   defaclacl&#61;%  defaclstr&#61;%  grantor&#61;%  grantee&#61;% &#39;, arec.atype, privs, arec.owner, arec.defaclacl, arec.defaclstr, grantor, grantee;&#10;          END IF;&#10;        END LOOP;&#10;      END;&#10;    END LOOP;&#10;&#10;    RAISE NOTICE &#39;  DFLT PRIVS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;  END IF; -- NO ACL BRANCH&#10;&#10;  -- Issue#95 bypass if No ACL specified&#10;  IF NOT bNoACL THEN&#10;    -- MV: PRIVS: schema&#10;    -- crunchy data extension, check_access&#10;    -- SELECT role_path, base_role, as_role, objtype, schemaname, objname, array_to_string(array_agg(privname),&#39;,&#39;) as privs  FROM all_access()&#10;    -- WHERE base_role !&#61; CURRENT_USER and objtype &#61; &#39;schema&#39; and schemaname &#61; &#39;public&#39; group by 1,2,3,4,5,6;&#10;&#10;    action :&#61; &#39;PRIVS: Schema&#39;;&#10;    cnt :&#61; 0;&#10;    FOR arec IN&#10;      SELECT &#39;GRANT &#39; || p.perm::perm_type || &#39; ON SCHEMA &#39; || quote_ident(dest_schema) || &#39; TO &quot;&#39; || r.rolname || &#39;&quot;;&#39; as schema_ddl&#10;      FROM pg_catalog.pg_namespace AS n&#10;      CROSS JOIN pg_catalog.pg_roles AS r&#10;      CROSS JOIN (VALUES (&#39;USAGE&#39;), (&#39;CREATE&#39;)) AS p(perm)&#10;      WHERE n.nspname &#61; quote_ident(source_schema) AND NOT r.rolsuper AND has_schema_privilege(r.oid, n.oid, p.perm)&#10;      ORDER BY r.rolname, p.perm::perm_type&#10;    LOOP&#10;      BEGIN&#10;        cnt :&#61; cnt + 1;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.schema_ddl;&#10;        ELSE&#10;          EXECUTE arec.schema_ddl;&#10;        END IF;&#10;&#10;      END;&#10;    END LOOP;&#10;    RAISE NOTICE &#39;SCHEMA PRIVS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;  END IF; -- NO ACL BRANCH&#10;&#10;  -- Issue#95 bypass if No ACL specified&#10;  IF NOT bNoACL THEN&#10;    -- MV: PRIVS: sequences&#10;    action :&#61; &#39;PRIVS: Sequences&#39;;&#10;    cnt :&#61; 0;&#10;    FOR arec IN&#10;      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on t.relname&#10;      SELECT &#39;GRANT &#39; || p.perm::perm_type || &#39; ON &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(t.relname::text) || &#39; TO &quot;&#39; || r.rolname || &#39;&quot;;&#39; as seq_ddl&#10;      FROM pg_catalog.pg_class AS t&#10;      CROSS JOIN pg_catalog.pg_roles AS r&#10;      CROSS JOIN (VALUES (&#39;SELECT&#39;), (&#39;USAGE&#39;), (&#39;UPDATE&#39;)) AS p(perm)&#10;      WHERE t.relnamespace::regnamespace::name &#61; quote_ident(source_schema) AND t.relkind &#61; &#39;S&#39;  AND NOT r.rolsuper AND has_sequence_privilege(r.oid, t.oid, p.perm)&#10;    LOOP&#10;      BEGIN&#10;        cnt :&#61; cnt + 1;&#10;        -- IF bDebug THEN RAISE NOTICE &#39;DEBUG: ddl&#61;%&#39;, arec.seq_ddl; END IF;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.seq_ddl;&#10;        ELSE&#10;          EXECUTE arec.seq_ddl;&#10;        END IF;&#10;      END;&#10;    END LOOP;&#10;    RAISE NOTICE &#39;  SEQ. PRIVS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;  END IF; -- NO ACL BRANCH&#10;&#10;  -- Issue#95 bypass if No ACL specified&#10;  IF NOT bNoACL THEN&#10;    -- MV: PRIVS: functions&#10;    action :&#61; &#39;PRIVS: Functions/Procedures&#39;;&#10;    cnt :&#61; 0;&#10;&#10;    -- Issue#61 FIX: use set_config for empty string&#10;    -- SET search_path &#61; &#39;&#39;;&#10;    SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false) into v_dummy;&#10;&#10;    -- RAISE NOTICE &#39; source_schema&#61;%  dest_schema&#61;%&#39;,source_schema, dest_schema;&#10;    FOR arec IN&#10;      -- 2021-03-05 MJV FIX: issue#35: caused exception in some functions with parameters and gave privileges to other users that should not have gotten them.&#10;      -- SELECT &#39;GRANT EXECUTE ON FUNCTION &#39; || quote_ident(dest_schema) || &#39;.&#39; || replace(regexp_replace(f.oid::regprocedure::text, &#39;^(((&quot;[^&quot;]*&quot;)|([^&quot;][^.]*))\.)?&#39;, &#39;&#39;), source_schema, dest_schema) || &#39; TO &quot;&#39; || r.rolname || &#39;&quot;;&#39; as func_ddl&#10;      -- FROM pg_catalog.pg_proc f CROSS JOIN pg_catalog.pg_roles AS r WHERE f.pronamespace::regnamespace::name &#61; quote_ident(source_schema) AND NOT r.rolsuper AND has_function_privilege(r.oid, f.oid, &#39;EXECUTE&#39;)&#10;      -- order by regexp_replace(f.oid::regprocedure::text, &#39;^(((&quot;[^&quot;]*&quot;)|([^&quot;][^.]*))\.)?&#39;, &#39;&#39;)&#10;&#10;      -- 2021-03-05 MJV FIX: issue#37: defaults cause problems, use system function that returns args WITHOUT DEFAULTS&#10;      -- COALESCE(r.routine_type, &#39;FUNCTION&#39;): for aggregate functions, information_schema.routines contains NULL as routine_type value.&#10;      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on rp.routine_name&#10;      SELECT &#39;GRANT &#39; || rp.privilege_type || &#39; ON &#39; || COALESCE(r.routine_type, &#39;FUNCTION&#39;) || &#39; &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(rp.routine_name) || &#39; (&#39; || pg_get_function_identity_arguments(p.oid) || &#39;) TO &#39; || string_agg(distinct rp.grantee, &#39;,&#39;) || &#39;;&#39; as func_dcl&#10;      FROM information_schema.routine_privileges rp, information_schema.routines r, pg_proc p, pg_namespace n&#10;      WHERE rp.routine_schema &#61; quote_ident(source_schema)&#10;        AND rp.is_grantable &#61; &#39;YES&#39;&#10;        AND rp.routine_schema &#61; r.routine_schema&#10;        AND rp.routine_name &#61; r.routine_name&#10;        AND rp.routine_schema &#61; n.nspname&#10;        AND n.oid &#61; p.pronamespace&#10;        AND p.proname &#61; r.routine_name&#10;      GROUP BY rp.privilege_type, r.routine_type, rp.routine_name, pg_get_function_identity_arguments(p.oid)&#10;    LOOP&#10;      BEGIN&#10;        cnt :&#61; cnt + 1;&#10;        IF bDDLOnly THEN&#10;          RAISE INFO &#39;%&#39;, arec.func_dcl;&#10;        ELSE&#10;          EXECUTE arec.func_dcl;&#10;        END IF;&#10;      END;&#10;    END LOOP;&#10;    EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;    RAISE NOTICE &#39;  FUNC PRIVS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;  END IF; -- NO ACL BRANCH&#10;&#10;  -- Issue#95 bypass if No ACL specified&#10;  IF NOT bNoACL THEN&#10;    -- MV: PRIVS: tables&#10;    action :&#61; &#39;PRIVS: Tables&#39;;&#10;    -- regular, partitioned, and foreign tables plus view and materialized view permissions. Ignored for now: implement foreign table defs.&#10;    cnt :&#61; 0;&#10;    FOR arec IN&#10;      -- SELECT &#39;GRANT &#39; || p.perm::perm_type || CASE WHEN t.relkind in (&#39;r&#39;, &#39;p&#39;, &#39;f&#39;) THEN &#39; ON TABLE &#39; WHEN t.relkind in (&#39;v&#39;, &#39;m&#39;)  THEN &#39; ON &#39; END || quote_ident(dest_schema) || &#39;.&#39; || t.relname::text || &#39; TO &quot;&#39; || r.rolname || &#39;&quot;;&#39; as tbl_ddl,&#10;      -- has_table_privilege(r.oid, t.oid, p.perm) AS granted, t.relkind&#10;      -- FROM pg_catalog.pg_class AS t CROSS JOIN pg_catalog.pg_roles AS r CROSS JOIN (VALUES (TEXT &#39;SELECT&#39;), (&#39;INSERT&#39;), (&#39;UPDATE&#39;), (&#39;DELETE&#39;), (&#39;TRUNCATE&#39;), (&#39;REFERENCES&#39;), (&#39;TRIGGER&#39;)) AS p(perm)&#10;      -- WHERE t.relnamespace::regnamespace::name &#61; quote_ident(source_schema)  AND t.relkind in (&#39;r&#39;, &#39;p&#39;, &#39;f&#39;, &#39;v&#39;, &#39;m&#39;)  AND NOT r.rolsuper AND has_table_privilege(r.oid, t.oid, p.perm) order by t.relname::text, t.relkind&#10;      -- 2021-03-05  MJV FIX: Fixed Issue#36 for tables&#10;      SELECT c.relkind, &#39;GRANT &#39; || tb.privilege_type || CASE WHEN c.relkind in (&#39;r&#39;, &#39;p&#39;) THEN &#39; ON TABLE &#39; WHEN c.relkind in (&#39;v&#39;, &#39;m&#39;)  THEN &#39; ON &#39; END ||&#10;      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on t.relname&#10;      quote_ident(dest_schema) || &#39;.&#39; || quote_ident(tb.table_name) || &#39; TO &#39; || string_agg(tb.grantee, &#39;,&#39;) || &#39;;&#39; as tbl_dcl&#10;      FROM information_schema.table_privileges tb, pg_class c, pg_namespace n&#10;      WHERE tb.table_schema &#61; quote_ident(source_schema) AND tb.table_name &#61; c.relname AND c.relkind in (&#39;r&#39;, &#39;p&#39;, &#39;v&#39;, &#39;m&#39;)&#10;        AND c.relnamespace &#61; n.oid AND n.nspname &#61; quote_ident(source_schema)&#10;        GROUP BY c.relkind, tb.privilege_type, tb.table_schema, tb.table_name&#10;    LOOP&#10;      BEGIN&#10;        cnt :&#61; cnt + 1;&#10;        -- IF bDebug THEN RAISE NOTICE &#39;DEBUG: ddl&#61;%&#39;, arec.tbl_dcl; END IF;&#10;        -- Issue#46. Fixed reference to invalid record name (tbl_ddl --&gt; tbl_dcl).&#10;        IF arec.relkind &#61; &#39;f&#39; THEN&#10;          RAISE WARNING &#39;Foreign tables are not currently implemented, so skipping privs for them. ddl&#61;%&#39;, arec.tbl_dcl;&#10;        ELSE&#10;            IF bDDLOnly THEN&#10;                RAISE INFO &#39;%&#39;, arec.tbl_dcl;&#10;            ELSE&#10;                EXECUTE arec.tbl_dcl;&#10;              END IF;&#10;      END IF;&#10;      END;&#10;    END LOOP;&#10;    RAISE NOTICE &#39; TABLE PRIVS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;  END IF; -- NO ACL BRANCH&#10;&#10;  -- LOOP for regular tables and populate them if specified&#10;  -- Issue#75 moved from big table loop above to here.&#10;  IF bData THEN&#10;    r &#61; clock_timestamp();&#10;    -- IF bVerbose THEN RAISE NOTICE &#39;START: copy rows %&#39;,clock_timestamp() - t; END IF;&#10;    IF bVerbose THEN RAISE NOTICE &#39;Copying rows...&#39;; END IF;&#10;&#10;    EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(dest_schema) ;&#10;    action :&#61; &#39;Copy Rows&#39;;&#10;    FOREACH tblelement IN ARRAY tblarray&#10;    LOOP&#10;       s &#61; clock_timestamp();&#10;       IF bDebug THEN RAISE NOTICE &#39;DEBUG1: no UDTs %&#39;, tblelement; END IF;&#10;       EXECUTE tblelement;&#10;       GET DIAGNOSTICS cnt &#61; ROW_COUNT;&#10;       buffer &#61; substring(tblelement, 13);&#10;       SELECT POSITION(&#39; OVERRIDING SYSTEM VALUE SELECT &#39; IN buffer) INTO cnt2;&#10;       IF cnt2 &#61; 0 THEN&#10;           SELECT POSITION(&#39; SELECT &#39; IN buffer) INTO cnt2;&#10;           buffer &#61; substring(buffer,1, cnt2);&#10;       ELSE&#10;           buffer &#61; substring(buffer,1, cnt2);&#10;       END IF;&#10;       SELECT RPAD(buffer, 35, &#39; &#39;) INTO buffer;&#10;       cnt2 :&#61; cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));&#10;       IF bVerbose THEN RAISE NOTICE &#39; Populated cloned table, %   Rows Copied: %    seconds: %&#39;, buffer, LPAD(cnt::text, 10, &#39; &#39;), LPAD(cnt2::text, 5, &#39; &#39;); END IF;&#10;       tblscopied :&#61; tblscopied + 1;&#10;    END LOOP;&#10;&#10;    -- Issue#79 implementation&#10;    -- Do same for tables with user-defined elements using copy to file method&#10;    FOREACH tblelement IN ARRAY tblarray2&#10;    LOOP&#10;       s &#61; clock_timestamp();&#10;       IF bDebug THEN RAISE NOTICE &#39;DEBUG2: UDTs %&#39;, tblelement; END IF;&#10;       EXECUTE tblelement;&#10;       GET DIAGNOSTICS cnt &#61; ROW_COUNT;&#10;       cnt2 &#61; POSITION(&#39; FROM &#39; IN tblelement::text);&#10;       IF cnt2 &gt; 0 THEN&#10;           buffer &#61; substring(tblelement, 1, cnt2);&#10;           buffer &#61; substring(buffer, 6);&#10;           SELECT RPAD(buffer, 35, &#39; &#39;) INTO buffer;&#10;           cnt2 :&#61; cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));&#10;           IF bVerbose THEN RAISE NOTICE &#39; Populated cloned table, %   Rows Copied: %    seconds: %&#39;, buffer, LPAD(cnt::text, 10, &#39; &#39;), LPAD(cnt2::text, 5, &#39; &#39;); END IF;&#10;           tblscopied :&#61; tblscopied + 1;&#10;       END IF;&#10;    END LOOP;&#10;&#10;    -- Issue#101&#10;    -- Do same for tables with user-defined elements using direct method with text cast&#10;    FOREACH tblelement IN ARRAY tblarray3&#10;    LOOP&#10;       s &#61; clock_timestamp();&#10;       IF bDebug THEN RAISE NOTICE &#39;DEBUG3: UDTs %&#39;, tblelement; END IF;&#10;       EXECUTE tblelement;&#10;       GET DIAGNOSTICS cnt &#61; ROW_COUNT;&#10;       cnt2 &#61; POSITION(&#39; (&#39; IN tblelement::text);&#10;       IF cnt2 &gt; 0 THEN&#10;           buffer &#61; substring(tblelement, 1, cnt2);&#10;           buffer &#61; substring(buffer, 6);&#10;           SELECT RPAD(buffer, 35, &#39; &#39;) INTO buffer;&#10;           cnt2 :&#61; cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));&#10;           IF bVerbose THEN RAISE NOTICE &#39; Populated cloned table, %   Rows Copied: %    seconds: %&#39;, buffer, LPAD(cnt::text, 10, &#39; &#39;), LPAD(cnt2::text, 5, &#39; &#39;); END IF;&#10;           tblscopied :&#61; tblscopied + 1;&#10;       END IF;&#10;    END LOOP;&#10;&#10;&#10;    -- Issue#98 MVs deferred until now&#10;    FOREACH tblelement IN ARRAY mvarray&#10;    LOOP&#10;       s &#61; clock_timestamp();&#10;       EXECUTE tblelement;&#10;       -- get diagnostics for MV creates or refreshes does not work, always returns 1&#10;       GET DIAGNOSTICS cnt &#61; ROW_COUNT;&#10;       buffer &#61; substring(tblelement, 25);&#10;       cnt2 &#61; POSITION(&#39; AS &#39; IN buffer);&#10;       IF cnt2 &gt; 0 THEN&#10;         buffer &#61; substring(buffer, 1, cnt2);&#10;         SELECT RPAD(buffer, 36, &#39; &#39;) INTO buffer;&#10;         cnt2 :&#61; cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));&#10;         IF bVerbose THEN RAISE NOTICE &#39; Populated Mat. View,   %   Rows Inserted:        ?    seconds: %&#39;, buffer, LPAD(cnt2::text, 5, &#39; &#39;); END IF;&#10;         mvscopied :&#61; mvscopied + 1;&#10;       END IF;&#10;    END LOOP;&#10;&#10;    cnt :&#61; cast(extract(epoch from (clock_timestamp() - r)) as numeric(18,3));&#10;    IF bVerbose THEN RAISE NOTICE &#39;Copy rows duration: % seconds&#39;,cnt; END IF;&#10;  END IF;&#10;  RAISE NOTICE &#39;      TABLES copied: %&#39;, LPAD(tblscopied::text, 5, &#39; &#39;);&#10;  RAISE NOTICE &#39; MATVIEWS refreshed: %&#39;, LPAD(mvscopied::text, 5, &#39; &#39;);&#10;&#10;&#10;  -- Issue#78 forces us to defer FKeys until the end since we previously did row copies before FKeys&#10;  --  add FK constraint&#10;  action :&#61; &#39;FK Constraints&#39;;&#10;  cnt :&#61; 0;&#10;&#10;  -- Issue#61 FIX: use set_config for empty string&#10;  -- SET search_path &#61; &#39;&#39;;&#10;  SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false) into v_dummy;&#10;&#10;  FOR qry IN&#10;    SELECT &#39;ALTER TABLE &#39; || quote_ident(dest_schema) || &#39;.&#39; || quote_ident(rn.relname)&#10;                          || &#39; ADD CONSTRAINT &#39; || quote_ident(ct.conname) || &#39; &#39; || REPLACE(pg_get_constraintdef(ct.oid), &#39;REFERENCES &#39; || quote_ident(source_schema) || &#39;.&#39;, &#39;REFERENCES &#39;&#10;                          || quote_ident(dest_schema) || &#39;.&#39;) || &#39;;&#39;&#10;    FROM pg_constraint ct&#10;    JOIN pg_class rn ON rn.oid &#61; ct.conrelid&#10;    -- Issue#103 needed to addd this left join&#10;    LEFT JOIN pg_inherits i ON (rn.oid &#61; i.inhrelid)&#10;    WHERE connamespace &#61; src_oid&#10;        AND rn.relkind &#61; &#39;r&#39;&#10;        AND ct.contype &#61; &#39;f&#39;&#10;        -- Issue#103 fix: needed to also add this null check&#10;        AND i.inhrelid is null&#10;  LOOP&#10;    cnt :&#61; cnt + 1;&#10;    IF bDDLOnly THEN&#10;      RAISE INFO &#39;%&#39;, qry;&#10;    ELSE&#10;      IF bDebug THEN RAISE NOTICE &#39;DEBUG: adding FKEY constraint: %&#39;, qry; END IF;&#10;      EXECUTE qry;&#10;    END IF;&#10;  END LOOP;&#10;  EXECUTE &#39;SET search_path &#61; &#39; || quote_ident(source_schema) ;&#10;  RAISE NOTICE &#39;       FKEYS cloned: %&#39;, LPAD(cnt::text, 5, &#39; &#39;);&#10;&#10;&#10;  IF src_path_old &#61; &#39;&#39; OR src_path_old &#61; &#39;&quot;&quot;&#39; THEN&#10;    -- RAISE NOTICE &#39;Restoring old search_path to empty string&#39;;&#10;    SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false) into v_dummy;&#10;  ELSE&#10;    -- RAISE NOTICE &#39;Restoring old search_path to:%&#39;, src_path_old;&#10;    EXECUTE &#39;SET search_path &#61; &#39; || src_path_old;&#10;  END IF;&#10;  SELECT setting INTO v_dummy FROM pg_settings WHERE name &#61; &#39;search_path&#39;;&#10;  IF bDebug THEN RAISE NOTICE &#39;DEBUG: setting search_path back to what it was: %&#39;, v_dummy; END IF;&#10;  cnt :&#61; cast(extract(epoch from (clock_timestamp() - t)) as numeric(18,3));&#10;  IF bVerbose THEN RAISE NOTICE &#39;clone_schema duration: % seconds&#39;,cnt; END IF;&#10;&#10;  EXCEPTION&#10;     WHEN others THEN&#10;     BEGIN&#10;         GET STACKED DIAGNOSTICS v_diag1 &#61; MESSAGE_TEXT, v_diag2 &#61; PG_EXCEPTION_DETAIL, v_diag3 &#61; PG_EXCEPTION_HINT, v_diag4 &#61; RETURNED_SQLSTATE, v_diag5 &#61; PG_CONTEXT, v_diag6 &#61; PG_EXCEPTION_CONTEXT;&#10;         v_ret :&#61; &#39;line&#61;&#39; || v_diag6 || &#39;. &#39;|| v_diag4 || &#39;. &#39; || v_diag1;&#10;         -- Issue#101: added version to exception output&#10;         -- RAISE NOTICE &#39;v_diag1&#61;%  v_diag2&#61;%  v_diag3&#61;%  v_diag4&#61;%  v_diag5&#61;%  v_diag6&#61;%&#39;, v_diag1, v_diag2, v_diag3, v_diag4, v_diag5, v_diag6;&#10;         buffer2 &#61; &#39;&#39;;&#10;         IF action &#61; &#39;Copy Rows&#39; AND v_diag4 &#61; &#39;42704&#39; THEN&#10;             -- Issue#105 Help user to fix the problem.&#10;             buffer2 &#61; &#39;It appears you have a USER-DEFINED column type mismatch.  Try running clone_schema with the FILECOPY option. &#39;;&#10;         END IF;&#10;         buffer &#61; v_ret || E&#39;\n&#39;|| buffer2;&#10;         RAISE EXCEPTION &#39;Version: %  Action: %  Diagnostics: %&#39;,v_version, action, buffer;&#10;&#10;         IF src_path_old &#61; &#39;&#39; THEN&#10;           -- RAISE NOTICE &#39;setting old search_path to empty string&#39;;&#10;           SELECT set_config(&#39;search_path&#39;, &#39;&#39;, false);&#10;         ELSE&#10;           -- RAISE NOTICE &#39;setting old search_path to:%&#39;, src_path_old;&#10;           EXECUTE &#39;SET search_path &#61; &#39; || src_path_old;&#10;         END IF;&#10;&#10;         RETURN;&#10;     END;&#10;&#10;RETURN;&#10;END;</textarea>
                        </div>
                    </div>
                </section>
            </div>
            <!-- /.content-wrapper -->
            <footer class="main-footer">
                <div>
                    <div class="pull-right hidden-xs">
                        <a href="https://github.com/schemaspy/schemaspy" title="GitHub for SchemaSpy"><i class="fa fa-github-square fa-2x"></i></a>
                        <a href="http://stackoverflow.com/questions/tagged/schemaspy" title="StackOverflow for SchemaSpy"><i class="fa fa-stack-overflow fa-2x"></i></a>
                    </div>
                    <strong>Generated by <a href="http://schemaspy.org/" class="logo-text"><i class="fa fa-database"></i> SchemaSpy 6.2.2</a></strong>
                </div>
                <!-- /.container -->
            </footer>
        </div>
        <!-- ./wrapper -->

        <!-- jQuery 2.2.3 -->
        <script src="../bower/admin-lte/plugins/jQuery/jquery-2.2.3.min.js"></script>
        <script src="../bower/admin-lte/plugins/jQueryUI/jquery-ui.min.js"></script>
        <!-- Bootstrap 3.3.5 -->
        <script src="../bower/admin-lte/bootstrap/js/bootstrap.min.js"></script>
        <!-- DataTables -->
        <script src="../bower/datatables.net/jquery.dataTables.min.js"></script>
        <script src="../bower/datatables.net-bs/js/dataTables.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/dataTables.buttons.min.js"></script>
        <script src="../bower/datatables.net-buttons-bs/js/buttons.bootstrap.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.html5.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.print.min.js"></script>
        <script src="../bower/datatables.net-buttons/buttons.colVis.min.js"></script>
        <!-- SheetJS -->
        <script src="../bower/js-xlsx/xlsx.full.min.js"></script>
        <!-- pdfmake -->
        <script src="../bower/pdfmake/pdfmake.min.js"></script>
        <script src="../bower/pdfmake/vfs_fonts.js"></script>
        <!-- SlimScroll -->
        <script src="../bower/admin-lte/plugins/slimScroll/jquery.slimscroll.min.js"></script>
        <!-- FastClick -->
        <script src="../bower/admin-lte/plugins/fastclick/fastclick.js"></script>
        <!-- Salvattore -->
        <script src="../bower/salvattore/salvattore.min.js"></script>
        <!-- AnchorJS -->
        <script src="../bower/anchor-js/anchor.min.js"></script>
        <!-- CodeMirror -->
        <script src="../bower/codemirror/codemirror.js"></script>
        <script src="../bower/codemirror/sql.js"></script>
        <!-- AdminLTE App -->
        <script src="../bower/admin-lte/dist/js/app.min.js"></script>
        <script src="routine.js"></script>
        <script src="../schemaSpy.js"></script>
    </body>
</html>